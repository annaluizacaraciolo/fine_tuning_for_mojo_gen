output,instruction,input,original author
"@always_inline
fn assert_true[
    T: Boolable
](val: T, msg: String = ""condition was unexpectedly False"") raises:

    if not val:
        raise Error(""AssertionError: "" + msg)",,"Asserts that the input value is True. If it is not then an
    Error is raised.

    Parameters:
        T: A Boolable type.

    Args:
        val: The value to assert to be True.
        msg: The message to be printed if the assertion fails.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
  ",modular mojo
"@always_inline
fn assert_false[
    T: Boolable
](val: T, msg: String = ""condition was unexpectedly True"") raises:

    if val:
        raise Error(""AssertionError: "" + msg)",,"Asserts that the input value is False. If it is not then an Error is
    raised.

    Parameters:
        T: A Boolable type.

    Args:
        val: The value to assert to be False.
        msg: The message to be printed if the assertion fails.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
   ",modular mojo
"@always_inline
fn assert_equal(lhs: Int, rhs: Int, msg: String = """") raises:

    if lhs != rhs:
        raise _assert_equal_error(str(lhs), str(rhs), msg=msg)",,"Asserts that the input values are equal. If it is not then an Error
    is raised.

    Args:
        lhs: The lhs of the equality.
        rhs: The rhs of the equality.
        msg: The message to be printed if the assertion fails.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
    ",modular mojo
"@always_inline
fn assert_equal(lhs: String, rhs: String, msg: String = """") raises:

    if lhs != rhs:
        raise _assert_equal_error(lhs, rhs, msg=msg)",," Asserts that the input values are equal. If it is not then an Error
    is raised.

    Args:
        lhs: The lhs of the equality.
        rhs: The rhs of the equality.
        msg: The message to be printed if the assertion fails.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
    ",modular mojo
"@always_inline
fn assert_equal[
    type: DType, size: Int
](lhs: SIMD[type, size], rhs: SIMD[type, size], msg: String = """") raises:

    if lhs != rhs:
        raise _assert_equal_error(str(lhs), str(rhs), msg=msg)",,"Asserts that the input values are equal. If it is not then an
    Error is raised.

    Parameters:
        type: The dtype of the left- and right-hand-side SIMD vectors.
        size: The width of the left- and right-hand-side SIMD vectors.

    Args:
        lhs: The lhs of the equality.
        rhs: The rhs of the equality.
        msg: The message to be printed if the assertion fails.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
",modular mojo
"@always_inline
fn assert_not_equal(lhs: Int, rhs: Int, msg: String = """") raises:

    if lhs == rhs:
        raise _assert_not_equal_error(str(lhs), str(rhs), msg=msg)",,"Asserts that the input values are not equal. If it is not then an
    Error is raised.

    Args:
        lhs: The lhs of the inequality.
        rhs: The rhs of the inequality.
        msg: The message to be printed if the assertion fails.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
    ",modular mojo
"@always_inline
fn assert_not_equal(lhs: String, rhs: String, msg: String = """") raises:

    if lhs == rhs:
        raise _assert_not_equal_error(str(lhs), str(rhs), msg=msg)",,"Asserts that the input values are not equal. If it is not then an
    an Error is raised.

    Args:
        lhs: The lhs of the inequality.
        rhs: The rhs of the inequality.
        msg: The message to be printed if the assertion fails.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
    ",modular mojo
"@always_inline
fn assert_not_equal[
    type: DType, size: Int
](lhs: SIMD[type, size], rhs: SIMD[type, size], msg: String = """") raises:

    if lhs == rhs:
        raise _assert_not_equal_error(str(lhs), str(rhs), msg=msg)",,"Asserts that the input values are not equal. If it is not then an
    Error is raised.

    Parameters:
        type: The dtype of the left- and right-hand-side SIMD vectors.
        size: The width of the left- and right-hand-side SIMD vectors.

    Args:
        lhs: The lhs of the inequality.
        rhs: The rhs of the inequality.
        msg: The message to be printed if the assertion fails.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
    ",modular mojo
"@always_inline
fn assert_almost_equal[
    type: DType, size: Int
](
    lhs: SIMD[type, size],
    rhs: SIMD[type, size],
    /,
    *,
    msg: String = """",
    atol: Scalar[type] = 1e-08,
    rtol: Scalar[type] = 1e-05,
) raises:

    var almost_equal = _isclose(lhs, rhs, atol=atol, rtol=rtol)
    if not almost_equal:
        var err = ""AssertionError: "" + str(lhs) + "" is not close to "" + str(
            rhs
        ) + "" with a diff of "" + _abs(lhs - rhs)
        if msg:
            err += "" ("" + msg + "")""
        raise err
",,"Asserts that the input values are equal up to a tolerance. If it is
    not then an Error is raised.

    Parameters:
        type: The dtype of the left- and right-hand-side SIMD vectors.
        size: The width of the left- and right-hand-side SIMD vectors.

    Args:
        lhs: The lhs of the equality.
        rhs: The rhs of the equality.
        msg: The message to print.
        atol: The _absolute tolerance.
        rtol: The relative tolerance.

    Raises:
        An Error with the provided message if assert fails and `None` otherwise.
    ",modular mojo
"    fn __init__(inout self, *, contains: String):

        self.message_contains = contains",,"Construct a context manager matching specific errors.

        Args:
            contains: The test will only pass if the error message
                includes the literal text passed.
        ",modular mojo
"    fn __exit__(self) raises:

        raise Error(""AssertionError: Didn't raise"")
",,"Exit the context manager with no error.

        Raises:
            AssertionError: Always. The block must raise to pass the test.
        ",modular mojo
"fn is_defined[name: StringLiteral]() -> Bool:

    alias result = __mlir_attr[
        `#kgen.param.expr<get_env, `, name.value, `> : i1`
    ]
    return result",,"Return true if the named value is defined.

    Parameters:
        name: The name to test.

    Returns:
        True if the name is defined.
    ",modular mojo
"fn env_get_int[name: StringLiteral, default: Int]() -> Int:


    @parameter
    if is_defined[name]():
        return env_get_int[name]()
    else:
        return default",,"Try to get an integer-valued define. If the name is not defined, return
    a default value instead.

    Parameters:
        name: The name of the define.
        default: The default value to use.

    Returns:
        An integer parameter value.
    ",modular mojo
"@always_inline
fn _int_tuple_binary_apply[
    size: Int,
    binary_fn: fn (Int, Int) -> Int,
](a: StaticTuple[Int, size], b: StaticTuple[Int, size]) -> StaticTuple[
    Int, size
]:


    var c = StaticTuple[Int, size]()

    @always_inline
    @parameter
    fn do_apply[idx: Int]():
        var a_elem: Int = a.__getitem__[idx]()
        var b_elem: Int = b.__getitem__[idx]()
        c.__setitem__[idx](binary_fn(a_elem, b_elem))

    unroll[do_apply, size]()

    return c",,"Applies a given element binary function to each pair of corresponding
    elements in two tuples.

    Example Usage:
        var a: StaticTuple[Int, size]
        var b: StaticTuple[Int, size]
        var c = _int_tuple_binary_apply[size, Int.add](a, b)

    Parameters:
        size: Static size of the operand and result tuples.
        binary_fn: Binary function to apply to tuple elements.

    Args:
        a: Tuple containing lhs operands of the elementwise binary function.
        b: Tuple containing rhs operands of the elementwise binary function.

    Returns:
        Tuple containing the result.
 ",modular mojo
"@always_inline
fn _bool_tuple_reduce[
    size: Int,
    reduce_fn: fn (Bool, Bool) -> Bool,
](a: StaticTuple[mlir_bool, size], init: Bool) -> Bool:


    var c: Bool = init

    @always_inline
    @parameter
    fn do_reduce[idx: Int]():
        c = reduce_fn(c, a.__getitem__[idx]())

    unroll[do_reduce, size]()

    return c",,"Reduces the tuple argument with the given reduce function and initial
    value.

    Example Usage:
        var a: StaticTuple[mlir_bool, size]
        var c = _bool_tuple_reduce[size, _reduce_and_fn](a, True)

    Parameters:
        size: Static size of the operand and result tuples.
        reduce_fn: Reduce function to accumulate tuple elements.

    Args:
        a: Tuple containing elements to reduce.
        init: Value to initialize the reduction with.

    Returns:
        The result of the reduction.
    ",modular mojo
"@value
@register_passable(""trivial"")
struct StaticIntTuple[size: Int](Sized, Stringable, EqualityComparable):


    var data: StaticTuple[Int, size]
    """"""The underlying storage of the tuple value.""""""

    @always_inline
    fn __init__() -> Self:
        """"""Constructs a static int tuple of the given size.

        Returns:
            The constructed tuple.
        """"""
        return 0",,"A base struct that implements size agnostic index functions.

    Parameters:
        size: The size of the tuple.
    ",modular mojo
"    @always_inline
    fn __init__(value: __mlir_type.index) -> Self:

        constrained[size == 1]()
        return Int(value)",,"Constructs a sized 1 static int tuple of given the element value.

        Args:
            value: The initial value.

        Returns:
            The constructed tuple.
        ",modular mojo
"    @always_inline
    fn __init__(elems: Tuple[Int, Int]) -> Self:
 

        var num_elements = len(elems)

        debug_assert(
            size == num_elements,
            ""[StaticIntTuple] mismatch in the number of elements"",
        )

        var tup = Self()

        @parameter
        fn fill[idx: Int]():
            tup[idx] = elems.get[idx, Int]()

        unroll[fill, 2]()

        return tup",,"Constructs a static int tuple given a tuple of integers.

        Args:
            elems: The tuple to copy from.

        Returns:
            The constructed tuple.
        ",modular mojo
"    @always_inline
    fn __init__(*elems: Int) -> Self:
        var num_elements = len(elems)

        debug_assert(
            size == num_elements,
            ""[StaticIntTuple] mismatch in the number of elements"",
        )

        var tup = Self()

        @unroll
        for idx in range(size):
            tup[idx] = elems[idx]

        return tup",,"Constructs a static int tuple given a set of arguments.

        Args:
            elems: The elements to construct the tuple.

        Returns:
            The constructed tuple.
        
",modular mojo
"    @always_inline
    fn __init__(values: VariadicList[Int]) -> Self:

        constrained[size > 0]()
        return Self {data: values}

    @always_inline(""nodebug"")
    fn __len__(self) -> Int:
        """"""Returns the size of the tuple.

        Returns:
            The tuple size.
        """"""
        return size",,"Creates a tuple constant using the specified values.

        Args:
            values: The list of values.

        Returns:
            A tuple with the values filled in.
",modular mojo
"@always_inline
fn _fp_bitcast_to_integer[type: DType](value: Scalar[type]) -> Int:

    alias integer_type = _integral_type_of[type]()
    return int(bitcast[integer_type, 1](value))",,"Bitcasts the floating-point value to an integer.

    Parameters:
        type: The floating-point type.

    Args:
        value: The value to bitcast.

    Returns:
        An integer representation of the floating-point value.
    ",modular mojo
"    @staticmethod
    @always_inline
    fn exponent_mantissa_mask() -> Int:

        constrained[
            type.is_floating_point(),
            ""dtype must be a floating point type"",
        ]()
        return Self.exponent_mask() + Self.mantissa_mask()",," Returns the exponent and mantissa mask of a floating point type. It is
        computed by `exponent_mask + mantissa_mask`.

        Returns:
            The exponent and mantissa mask.
",modular mojo
"    @staticmethod
    @always_inline
    fn bitcast_to_integer(value: Scalar[type]) -> Int:

        return _fp_bitcast_to_integer[type](value)",,"Bitcasts the floating-point value to an integer.

        Args:
            value: The floating-point type.

        Returns:
            An integer representation of the floating-point value.
        ",modular mojo
"    @staticmethod
    @always_inline
    fn bitcast_from_integer(value: Int) -> Scalar[type]:

        return _fp_bitcast_from_integer[type](value)",,"Bitcasts the floating-point value from an integer.

        Args:
            value: The int value.

        Returns:
            An floating-point representation of the Int.
",modular mojo
"    @staticmethod
    @always_inline
    fn get_sign(value: Scalar[type]) -> Bool:


        return (Self.bitcast_to_integer(value) & Self.sign_mask()) != 0",,"Returns the sign of the floating point value. True if the sign is set
        and False otherwise.

        Args:
            value: The floating-point type.

        Returns:
            Returns True if the sign is set and False otherwise.
        ",modular mojo
"    @staticmethod
    @always_inline
    fn get_exponent(value: Scalar[type]) -> Int:
 
        return (
            Self.bitcast_to_integer(value) & Self.exponent_mask()
        ) >> Self.mantissa_width()",,"Returns the exponent bits of the floating-point value.

        Args:
            value: The floating-point value.

        Returns:
            Returns the exponent bits.
        ",modular mojo
"@always_inline
    fn __init__(value: Self.pointer_type) -> Self:
      
        return Self {value: value}",,"Create a pointer with the input value.

        Args:
            value: The input pointer to construct with.

        Returns:
            A null pointer.
        ",modular mojo
"    @staticmethod
    @always_inline
    fn alloc(count: Int) -> Self:

        return Self.__from_index(
            int(_malloc[Int8](sizeof[T]() * count, alignment=alignof[T]()))
        )",,"Allocate an array with default alignment.

        Args:
            count: The number of elements in the array.

        Returns:
            The pointer to the newly allocated array.
    ",modular mojo
"    @staticmethod
    @always_inline(""nodebug"")
    fn address_of(inout arg: T) -> Self:

        return __mlir_op.`pop.pointer.bitcast`[_type = Self.pointer_type](
            __get_lvalue_as_address(arg)
        )",,"Gets the address of the argument.

        Args:
            arg: The value to get the address of.

        Returns:
            An AnyPointer which contains the address of the argument.
        ",modular mojo
"    @always_inline
    fn free(self):
        
        Pointer[Int8].__from_index(int(self)).free()",,Free the memory referenced by the pointer.,modular mojo
"    @always_inline
    fn take_value(self) -> T:

        return __get_address_as_owned_value(self.value)",,"Move the value at the pointer out.

        The pointer must not be null, and the pointer memory location is assumed
        to contain a valid initialized instance of `T`.

        This performs a _consuming_ move, ending the lifetime of the value stored
        in this pointer memory location. Subsequent reads of this pointer are
        not valid. If a new valid value is stored using `emplace_value()`, then
        reading from this pointer becomes valid again.

        Returns:
            The value at the pointer.
        ",modular mojo
"    @always_inline
    fn emplace_value(self, owned value: T):

        __get_address_as_uninit_lvalue(self.value) = value ^",,"Emplace a new value into the pointer location.

        The pointer memory location is assumed to contain uninitialized data,
        and consequently the current contents of this pointer are not destructed
        before writing `value`. Similarly, ownership of `value` is logically
        transfered into the pointer location.

        Args:
            value: The value to emplace.
    ",modular mojo
"    @always_inline
    fn move_into(self, dest: AnyPointer[T]):

        __get_address_as_uninit_lvalue(
            dest.value
        ) = __get_address_as_owned_value(self.value)
",,"Moves the value contained in this pointer into the memory location
        pointed to by `dest`.

        This performs a consuming move (using `__moveinit__()`) out of the
        memory location pointed to by this pointer. Subsequent reads of this
        pointer are not valid unless and until a new, valid value has been
        moved into this pointer's memory location using `emplace_value()`.

        This transfers the value out of `self` and into `dest` using at most one
        `__moveinit__()` call.

        Safety:
            * `self` must not be null
            * `self` must contain a valid, initialized instance of `T`
            * `dest` must not be null
            * The contents of `dest` should be uninitialized. If `dest` was
              previously written with a valid value, that value will be be
              overwritten and its destructor will NOT be run.

        Args:
            dest: Destination pointer that the value will be moved into.
        ",modular mojo
"    @always_inline
    fn __int__(self) -> Int:

        return __mlir_op.`pop.pointer_to_index`[
            _type = __mlir_type.`!pop.scalar<index>`
        ](self.value)",,"Returns the pointer address as an integer.

        Returns:
          The address of the pointer as an Int.
        ",modular mojo
"    @always_inline
    fn __bool__(self) -> Bool:

        return int(self) != 0",,"Return true if the pointer is non-null.

        Returns:
            Whether the pointer is null.
        ",modular mojo
"    @always_inline
    fn __add__(self, offset: Int) -> Self:

        return Self.__from_index(int(self) + offset * sizeof[T]())",,"Return a pointer at an offset from the current one.

        Args:
            offset: The offset index.

        Returns:
            An offset pointer.
        ",modular mojo
"    @always_inline
    fn __sub__(self, offset: Int) -> Self:

        return self + (-offset)",,"Return a pointer at an offset from the current one.

        Args:
            offset: The offset index.

        Returns:
            An offset pointer.
        ",modular mojo
"    @always_inline(""nodebug"")
    fn __eq__(self, rhs: Self) -> Bool:

        return int(self) == int(rhs)",,"Returns True if the two pointers are equal.

        Args:
            rhs: The value of the other pointer.

        Returns:
            True if the two pointers are equal and False otherwise.
        ",modular mojo
"    @always_inline(""nodebug"")
    fn __ne__(self, rhs: Self) -> Bool:

        return not (self == rhs)",,"Returns True if the two pointers are not equal.

        Args:
            rhs: The value of the other pointer.

        Returns:
            True if the two pointers are not equal and False otherwise.
        ",modular mojo