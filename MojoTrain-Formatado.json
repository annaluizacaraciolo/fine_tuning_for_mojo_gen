[{"output": "fn sigmoid(x: Float64) -> Float64:\r\n    return 1 / (1 + exp(-x))", "input": "Write a function to calculate the sigmoid of a given number"}, {"output": "fn gradient_descent(start: Float64, learning_rate: Float64, n_iter: Int=50, tolerance: Float64=1e-06) raises:\r\n    let np = Python.import_module('numpy')\r\n    var vector = start\r\n    for _ in range(n_iter):\r\n        let diff = -learning_rate * 2 * vector\r\n        if np.all(np.abs(diff) <= tolerance):\r\n            break\r\n        vector += diff\r\n    print(vector)", "input": "Write a function that calculates gradient descent"}, {"output": "fn main():\r\n    print(\"Hello, world!\")", "input": "Print hello world in mojo"}, {"output": "fn euclidean_dist(x1: Int64, y1: Int64, x2: Int64, y2: Int64):\r\n    let x = x2 - x1\r\n    let y = y2 - y1\r\n    let euclidean_distance = sqrt(pow(x, 2) + pow(y,2))\r\n    print(euclidean_distance)", "input": "Write a function to calculate the euclideadn distance between two points"}, {"output": "def mandelbrot_kernel(c: ComplexFloat64) -> Int:\r\n    z = c\r\n    for i in range(MAX_ITERS):\r\n        z = z * z + c\r\n        if z.squared_norm() > 4:\r\n            return i\r\n    return MAX_ITERS", "input": "Compute the number of steps to escape."}, {"output": "def compute_mandelbrot() -> Tensor[float_type]:\r\n    # create a matrix. Each element of the matrix corresponds to a pixel\r\n    t = Tensor[float_type](height, width)\r\n\r\n    dx = (max_x - min_x) / width\r\n    dy = (max_y - min_y) / height\r\n\r\n    y = min_y\r\n    for row in range(height):\r\n        x = min_x\r\n        for col in range(width):\r\n            t[Index(row, col)] = mandelbrot_kernel(ComplexFloat64(x, y))\r\n            x += dx\r\n        y += dy\r\n    return t", "input": "Write a function to compute the mandelbrot set"}, {"output": "    fn is_https(self) -> Bool:\r\n        return bytes_equal(self.__scheme, strHttps)", "input": "An instance method called is_https that returns a boolean value if the scheme of the request is HTTPS."}, {"output": "    fn path_original(self) -> Bytes:\r\n        return self.__path_original", "input": "Returns the original path (as Bytes) of the object without any modifications."}, {"output": "    fn set_path(inout self, path: String) -> Self:\r\n        self.__path = normalise_path(path._buffer, self.__path_original)", "input": "Sets the object's path to a new value, given as a String. "}, {"output": "    fn set_path_sbytes(inout self, path: Bytes) -> Self:\r\n        self.__path = normalise_path(path, self.__path_original)\r\n        return self", "input": "Similar to set_path, but accepts the new path as a Bytes object. It sets the object's path to this new bytes value after normalizing it. Returns the object itself for chaining."}, {"output": "    fn path(self) -> String:\n        var processed_path = self.__path\n        if len(processed_path) == 0:\n            processed_path = strSlash\n        return String(processed_path)\n", "input": "Retrieves the current path of the object. If the path is empty, it defaults to a predefined slash string (strSlash). The path is returned as a String."}, {"output": "    fn set_scheme(inout self, scheme: String) -> Self:\r\n        self.__scheme = scheme._buffer\r\n        return self\r\n\r", "input": "Sets the object's scheme (e.g., \"http\", \"https\") using a String value."}, {"output": "    fn set_scheme_bytes(inout self, scheme: Bytes) -> Self:\r\n        self.__scheme = scheme\r\n        return self", "input": "Sets the object's scheme using a Bytes object. Returns the object for further method chaining."}, {"output": "    fn scheme(self) -> Bytes:\r\n        var processed_scheme = self.__scheme\r\n        if len(processed_scheme) == 0:\r\n            processed_scheme = strHttp\r\n        return processed_scheme\r", "input": "Returns the current scheme of the object as a Bytes object. If no scheme is set (i.e., the scheme is empty), it defaults to \"http\"."}, {"output": "    fn is_https(self) -> Bool:\r\n        return bytes_equal(self.__scheme, strHttps)", "input": "Checks if the current scheme is \"https\" by comparing the scheme's bytes to a predefined strHttps bytes object. Returns True if they match, indicating an HTTPS scheme."}, {"output": "    fn is_http(self) -> Bool:\r\n        return bytes_equal(self.__scheme, strHttp) or len(self.__scheme) == 0", "input": "Determines whether the current scheme is \"http\". It checks if the scheme matches a predefined strHttp bytes object or if the scheme is empty, implying a default to \"http\". Returns True if either condition is met."}, {"output": "@value\r\nstruct ErrorHandler:\r\n    fn Error(self) -> HTTPResponse:\r\n        return HTTPResponse(ResponseHeader(), String(\"TODO\").as_bytes())\r\n\r\n\r\nalias errNeedMore = Error(\"need more data: cannot find trailing lf\")\r\nalias errInvalidName = Error(\"invalid header name\")\r\nalias errSmallBuffer = Error(\"small read buffer. Increase ReadBufferSize\")", "input": "This code snippet defines an ErrorHandler struct and introduces three error aliases related to handling HTTP errors or issues that might arise during HTTP request processing."}, {"output": "@value\r\nstruct HTTPResponse(Response):\r\n    var header: ResponseHeader\r\n    var stream_immediate_header_flush: Bool\r\n    var stream_body: Bool\r\n    var body_raw: Bytes\r\n    var skip_reading_writing_body: Bool\r\n    var raddr: TCPAddr\r\n    var laddr: TCPAddr\r\n\r\n    fn __init__(inout self, body_bytes: Bytes):\r\n        # TODO: infer content type from the body\r\n        self.header = ResponseHeader(\r\n            200,\r\n            String(\"OK\").as_bytes(),\r\n            String(\"Content-Type: application/octet-stream\\r\\n\").as_bytes(),\r\n        )\r\n        self.stream_immediate_header_flush = False\r\n        self.stream_body = False\r\n        self.body_raw = body_bytes\r\n        self.skip_reading_writing_body = False\r\n        self.raddr = TCPAddr()\r\n        self.laddr = TCPAddr()\r\n\r\n    fn __init__(inout self, header: ResponseHeader, body_bytes: Bytes):\r\n        self.header = header\r\n        self.stream_immediate_header_flush = False\r\n        self.stream_body = False\r\n        self.body_raw = body_bytes\r\n        self.skip_reading_writing_body = False\r\n        self.raddr = TCPAddr()\r\n        self.laddr = TCPAddr()", "input": "This code snippet defines an HTTPResponse struct, which is designed to encapsulate the details and functionality of an HTTP response within a server or client application. The struct contains various fields to represent the components of an HTTP response and provides two constructors (__init__ methods) for creating instances with different initializations."}, {"output": "    fn set_status_code(inout self, status_code: Int) -> Self:\r\n        _ = self.header.set_status_code(status_code)\r\n        return self", "input": "A method of the HTTPResponse struct (or a similar entity) designed to update the status code of the HTTP response."}, {"output": "    fn status_code(self) -> Int:\r\n        return self.header.status_code()", "input": "A method that returns the status code frin the header of the http response"}, {"output": "    fn connection_close(self) -> Bool:\r\n        return self.header.connection_close()", "input": "Define a function that returns a boolean indicating whether the HTTP response should signal the connection to close. It checks this status by accessing a method on the response header object."}, {"output": "fn OK(body: Bytes) -> HTTPResponse:\r\n    return HTTPResponse(\r\n        ResponseHeader(\r\n            True, 200, String(\"OK\").as_bytes(), String(\"Content-Type: text/plain\").as_bytes()\r\n        ),\r\n        body,\r\n    )", "input": " Implement a function that generates an HTTPResponse object with a 200 OK status code and a default Content-Type: text/plain. It accepts a byte array for the body content and uses default values for other headers."}, {"output": "fn OK(body: Bytes, content_type: String) -> HTTPResponse:\r\n    return HTTPResponse(\r\n        ResponseHeader(True, 200, String(\"OK\").as_bytes(), content_type.as_bytes()), body\r\n    )", "input": "Write a function that given the body of a message and the content type, returns an HTTP response with the header containing the status 200 and the body"}, {"output": "@value\nstruct TCPAddr(Addr):\n    var ip: String\n    var port: Int\n    var zone: String  # IPv6 addressing zone\n\n    fn __init__(inout self):\n        self.ip = String(\"127.0.0.1\")\n        self.port = 8000\n        self.zone = \"\"\n\n    fn __init__(inout self, ip: String, port: Int):\n        self.ip = ip\n        self.port = port\n        self.zone = \"\"\n\n    fn network(self) -> String:\n        return NetworkType.tcp.value\n\n    fn string(self) -> String:\n        if self.zone != \"\":\n            return join_host_port(String(self.ip) + \"%\" + self.zone, self.port)\n        return join_host_port(self.ip, self.port)\n", "input": "I need to define a struct to represent a TCP address; The attributes of the structure are the ip as string, port as int and zone as string. I also need constructors for the struct, one setting as default values         self.ip = String(\"127.0.0.1\"), self.port = 8000 and self.zone = \"\"  and another one taking custom inputs."}, {"output": "fn join_host_port(host: String, port: String) -> String:\n    if host.find(\":\") != -1:  # must be IPv6 literal\n        return \"[\" + host + \"]:\" + port\n    return host + \":\" + port", "input": "Write a method that receives two strings, a host and a port. If the last character of the host string is not \":\", return  \"[\" + host + \"]:\" + port. If it is, return host + \":\" + port."}, {"output": "    fn write(self, data: String) raises -> Int:\r\n        var buffer: Str\r\n        with Str(data) as buffer:\r\n            var write_count: c_ssize_t = external_call[\r\n                \"write\", c_ssize_t, c_int, char_pointer, c_size_t\r\n            ](self.fd, buffer.vector.data, data.__len__())\r\n\r\n            if write_count == -1:\r\n                raise Error(\"Failed to write to file descriptor \" + self.fd.__str__())\r\n\r\n            return write_count", "input": "Write an instance method that takes a string as input and returns an integer value. This method make an external call to write to a file and, if no error occurs, returns the number of bytes written."}, {"output": "@value\r\nstruct Printer(HTTPService):\r\n    fn func(self, req: HTTPRequest) raises -> HTTPResponse:\r\n        var body = req.body_raw\r\n        print(String(body))\r\n\r\n        return OK(body)", "input": "Write a struct Printer that takes HTTPService as argument, has a func method that takes an HTTPRequest as input and returns an HTTPResponse OK containing the body of the request as a string."}, {"output": "@value\r\nstruct Welcome(HTTPService):\r\n    fn func(self, req: HTTPRequest) raises -> HTTPResponse:\r\n        var html: String\r\n        with open(\"static/lightbug_welcome.html\", \"r\") as f:\r\n            html = f.read()\r\n\r\n        return OK(html.as_bytes(), \"text/html\")", "input": "Write a struct Welcome that has a method that takes an HTTP request, open a file, reads from it into the html variable and returns OK with the html."}, {"output": "@value\nstruct ExampleRouter(HTTPService):\n    fn func(self, req: HTTPRequest) raises -> HTTPResponse:\n        var body = req.body_raw\n        var uri = req.uri()\n\n        if uri.path() == \"/\":\n            print(\"I'm on the index path!\")\n        if uri.path() == \"/first\":\n            print(\"I'm on /first!\")\n        elif uri.path() == \"/second\":\n            print(\"I'm on /second!\")\n        elif uri.path() == \"/echo\":\n            print(String(body))\n\n        return OK(body)", "input": "This struct takes the HTTPService as a parameters and has an instance method. The insntance method takes an HTTP request as input and analyzes the uri: if the uri path is \"/\", then it prints into the console \"I'm on the index path!\", if the uri path is \"/first\" or \"/second\", it prints into the console\"I'm on /first!\" or \"I'm on /second!\", respectively. If the uri path is \"/echo\", it prints the body of the request as a string. At the end, this method should return an OK with the body of the message."}, {"output": "    @always_inline\n    fn __init__() -> Self:\n        # allocate a DTypePointer on stack that doesn't need to be freed.\n        var data = stack_allocation[width, T]()\n        memset_zero(data, width)\n        return Self {data: data}", "input": "A constructor method that allocates a pointer in a variable called data, which is initialized with zero, and returns an instance of the class."}, {"output": "    @always_inline\n    fn accumulate[_width: Int](inout self, val: SIMD[T, _width]) -> None:\n \n        var newVal = self.data.simd_load[_width]() + val\n        self.data.simd_store[_width](newVal)", "input": "This is a hack to make sure both SIMD have _width length.\r\n SIMD[T, width] += SIMD[T, _width] is always an error."}, {"output": "struct TensorSlice:\r\n    var _data: BufferPtrFloat32\r\n    var _shape: TensorShape\r\n\r\n    fn __init__(inout self, t: TensorF32, layer: Int) raises:\r\n        var elements_per_layer = t.num_elements() // t.dim(0)\r\n        self._data = t.data().offset(layer * elements_per_layer)\r\n        if t.rank() == 2:\r\n            self._shape = TensorShape(t.dim(1))\r\n        elif t.rank() == 3:\r\n            self._shape = TensorShape(t.dim(1), t.dim(2))\r\n        else:\r\n            # Compiler complains if _shape not defined\r\n            self._shape = TensorShape(1)\r\n            raise Error(\"TensorSlice: rank greater than 3 not implemented.\")", "input": "Provides a view into a tensor representing a 1D slice on its first or first 2 dimensions.\r\nSame function signatures as Tensor but without owning the data."}, {"output": "    fn simd_load[nelts: Int](self, idx: Int) -> SIMD[DType.float32, nelts]:\r\n        return self._data.simd_load[nelts](idx)", "input": "A function that loads data from an specific index into a SIMD structure that holds a float32 type."}, {"output": "fn read_val_int(inout buf: FileBuf) raises -> Int:\n    # DTypePointer[DType.ui8](buf.data).bitcast[DType.ui8]()\n    var data = buf.data.offset(buf.get_offset()).bitcast[DType.int32]()\n    var result = data.load(0)\n    buf.move_offset(4)\n    return result.to_int()\n", "input": "The read_val_int function reads an integer value from a file buffer (buf) and updates the buffer's offset accordingly and returns the read integer value."}, {"output": "fn read_val_float32(inout buf: FileBuf) raises -> Float32:\r\n    # DTypePointer[DType.ui8](buf.data).bitcast[DType.ui8]()\r\n    var val = buf.data.offset(buf.get_offset()).bitcast[DType.float32]().load(0)\r\n    buf.move_offset(4)\r\n    return val", "input": "The read_val_int function reads an integer value from a file buffer (buf) and updates the buffer's offset accordingly and returns the read float 32 value."}, {"output": "fn read_val_str(inout buf: FileBuf, slen: Int) raises -> PointerString:\r\n    var str = PointerString.alloc(slen + 1)\r\n    for i in range(slen):\r\n        str.store(i, buf.data.load(buf.get_offset()))\r\n        buf.move_offset(1)\r\n    str.store(slen, 0)\r\n\r\n    return str", "input": "The read_val_str reads from a file buffer each character from a string and returns that string."}, {"output": "fn partition(\r\n    inout array: PointerStrings, inout indices: DynamicVector[Int], low: Int, high: Int\r\n) -> Int:\r\n    var pivot = array[high]\r\n    var ii = low - 1\r\n    for jj in range(low, high):\r\n        if string_compare(pivot, array[jj]) == 1:\r\n            # If element smaller than pivot, swap\r\n            ii = ii + 1\r\n\r\n            var tmp = array[ii]\r\n            var tmp_idx = indices[ii]\r\n            array.store(ii, array[jj])\r\n            indices[ii] = indices[jj]\r\n            array.store(jj, tmp)\r\n            indices[jj] = tmp_idx\r\n\r\n    # Swap the pivot element\r\n    var tmp = array[ii + 1]\r\n    var tmp_idx = indices[ii + 1]\r\n    array.store(ii + 1, array[high])\r\n    indices[ii + 1] = indices[high]\r\n    array.store(high, tmp)\r\n    indices[high] = tmp_idx\r\n\r\n    return ii + 1\r\n", "input": "Quicksort helper function to find the partition position"}, {"output": "fn quicksort(\n    inout array: PointerStrings, inout indices: DynamicVector[Int], low: Int, high: Int\n):\n    if low < high:\n        var pi = partition(array, indices, low, high)\n        quicksort(array, indices, low, pi - 1)\n        quicksort(array, indices, pi + 1, high)", "input": "Quicksort function"}, {"output": "    fn move_offset(inout self, size: Int) raises:\r\n        var new_offset = self.offset + size\r\n        if new_offset > self.size:\r\n            raise Error(\"Resulting offset will be past the end of the FileBuf\")\r\n        if new_offset < 0:\r\n            raise Error(\"Resulting offset will be before the beginning of the FileBuf\")\r\n        self.offset = new_offset", "input": "The function move_offset takes an instance of a class and a integer, creates a variable called new_offset that is the offset of the instance plus the integer passed as argument and if the new_offset in greater than the original offset or less than zero, is raises an error, and if not, the offset of the instance becomes the value of new_offset."}, {"output": "    fn bitcast_offset_f32(inout self, size: Int) raises -> BufferPtrFloat32:\r\n        var ret = self.data.offset(self.offset).bitcast[DType.float32]()\r\n        self.move_offset(size * sizeof[DType.float32]())\r\n        return ret", "input": "This function, bitcast_offset_f32, performs a series of operations on a data structure to obtain a buffer pointer with a specific data type, while also updating an offset within the data structure. "}, {"output": "    fn get_offset(self) raises -> Int:\n        if self.offset > self.size:\n            raise Error(\"Offset is past the end of the FileBuf\")\n        if self.offset < 0:\n            raise Error(\"Offset is before the beginning of the FileBuf\")\n        return self.offset\n", "input": "This function get_offset is an instance method that returns an integer representing the offset and might raise an error. If the offset of the instance is greater than the size of the instance, if raises an error of \"Offset is past the end of the FileBuf\". If the offset of the instance is less than zero, then it raises an error of \"Offset is before the beginning of the FileBuf\"."}, {"output": "fn wrap(token: PointerString) -> PointerString:\n    if string_compare(token, str_to_ptr(\"\\\\n\")) == 0:\n        return str_to_ptr(\"<0x0A>\")\n    if string_compare(token, str_to_ptr(\"\\\\t\")) == 0:\n        return str_to_ptr(\"<0x09>\")\n    if string_compare(token, str_to_ptr(\"'\")) == 0:\n        return str_to_ptr(\"<0x27>\")\n    elif string_compare(token, str_to_ptr('\"')) == 0:\n        return str_to_ptr(\"<0x22>\")\n    return token\n", "input": "The function wrap takes a PointerString as input, which suggests it's working with a pointer to a string or a similar data structure representing text. Its primary purpose is to check if the input string matches certain special characters (newline \"\\n\", tab \"\\t\", single quote \"'\" and double quote \"\\\"\"), and return a pointer to a string that represents these characters in a hexadecimal escape sequence format. If the input string does not match any of the specified special characters, it simply returns the original input string."}, {"output": "struct Tokenizer:\n    var vocab: PointerStrings\n    var vocab_scores: BufferPtrFloat32\n    var max_token_length: Int\n    var vocab_size: Int\n    var sorted_vocab: PointerStrings\n    var sorted_indices: DynamicVector[Int]\n\n    fn __init__(inout self, vocab_size: Int, inout buf: FileBuf) raises -> None:\n        self.vocab_size = vocab_size\n        self.max_token_length = read_val_int(buf)\n        self.vocab_scores = BufferPtrFloat32.alloc(self.vocab_size)\n        self.vocab = PointerStrings.alloc(self.vocab_size)\n        # lazy load sorted vocab\n        self.sorted_vocab = PointerStrings.alloc(0)\n        self.sorted_indices = DynamicVector[Int]()\n\n        # read vocab_scores & vocab values (tokens)\n        for i in range(0, self.vocab_size):\n            var score = read_val_float32(buf)\n            var slen = read_val_int(buf)\n            var token = read_val_str(buf, slen)\n            self.store_token(i, token, score)\n        return None", "input": "The Tokenizer struct, along with its __init__ method, sets up an environment for tokenization tasks by initializing various components necessary for the tokenizer's operation. The __init__ method specifically prepares the tokenizer with its vocabulary and associated scores, among other settings, from a provided buffer."}, {"output": "    fn __del__(owned self):\n        for i in range(0, self.vocab_size):\n            self.vocab[i].free()\n        self.vocab.free()\n        self.vocab_scores.free()\n        self.sorted_vocab.free()\n", "input": "This is an instance method that iterates over a structure (self) and frees the memory that was allocated to that object."}, {"output": "fn sort(inout self) -> None:\r\n        if len(self.sorted_indices) < self.vocab_size:\r\n            self.sorted_indices = DynamicVector[Int](capacity=self.vocab_size)\r\n            self.sorted_vocab = PointerStrings.alloc(self.vocab_size)\r\n            for ii in range(self.vocab_size):\r\n                self.sorted_vocab.store(ii, self.vocab[ii])\r\n                self.sorted_indices.push_back(ii)\r\n\r\n        var n = self.vocab_size\r\n        quicksort(self.sorted_vocab, self.sorted_indices, 0, n - 1)\r\n        return None", "input": "Sort vocab by string_compare"}, {"output": "\r\n    fn find(inout self, token_o: PointerString) -> Int:\r\n        var token = wrap(token_o)\r\n        var n = self.vocab_size\r\n        if len(self.sorted_indices) < n:\r\n            self.sort()\r\n        var left = 0\r\n        var right = n - 1\r\n        while left <= right:\r\n            var mid = left + (right - left) // 2\r\n            var comparison = string_compare(self.sorted_vocab[mid], token)\r\n            if comparison == 0:\r\n                return self.sorted_indices[mid]\r\n            if comparison < 0:\r\n                left = mid + 1\r\n            else:\r\n                right = mid - 1\r\n        return -1", "input": "Binary search that returns -1 if string is not found"}, {"output": "@always_inline\nfn accum(inout a: TensorF32, b: TensorF32) -> None:\n    var size = a.dim(0)\n\n    @parameter\n    fn _acc[_nelts: Int](j: Int):\n        a.simd_store[_nelts](j, a.simd_load[_nelts](j) + b.simd_load[_nelts](j))\n\n    vectorize[_acc, nelts](size)", "input": "Write a function that takes two tensors of float numbers"}, {"output": "@always_inline\r\nfn softmax(inout x: TensorF32) -> None:\r\n    softmax(x, 0, x.dim(0))", "input": "Activation function softmax"}, {"output": "@always_inline\nfn rope_rotation_llama(\n    inout state: RunState,\n    freq_cis_real_row: TensorSlice,\n    freq_cis_imag_row: TensorSlice,\n    config: Config,\n) -> None:\n    # stories model, llama2\n    var head_size = config.head_size", "input": "Apply RoPE rotation to the q and k vectors for each head\nrotate odd and even dim"}, {"output": "    @parameter\r\n    fn head_loop(i: Int):\r\n\r\n        for j in range(0, config.head_size, 2):\r\n            var fcr = freq_cis_real_row[j // 2]\r\n            var fci = freq_cis_imag_row[j // 2]\r\n            var q0 = state.q[i * head_size + j]\r\n            var q1 = state.q[i * head_size + j + 1]\r\n            state.q[i * head_size + j] = q0 * fcr - q1 * fci\r\n            state.q[i * head_size + j + 1] = q0 * fci + q1 * fcr\r\n            if i < config.n_kv_heads:\r\n                var k0 = state.k[i * head_size + j]\r\n                var k1 = state.k[i * head_size + j + 1]\r\n                state.k[i * head_size + j] = k0 * fcr - k1 * fci\r\n                state.k[i * head_size + j + 1] = k0 * fci + k1 * fcr", "input": "        Simple vectorization with (head_size // 2) steps gave junk transformer output.\r\n        Maybe because the nelt ranges end up overlapping between the steps."}, {"output": "fn argmax(v: TensorF32) -> Int:\n  \n    var max_i: Int = 0\n    var max_p: Float32 = v[0]\n    for i in range(v.dim(0)):\n        if v[i] > max_p:\n            max_i = i\n            max_p = v[i]\n    return max_i\n", "input": " return argmax of v"}, {"output": "fn sample(probabilities: TensorF32) -> Int:\n    var n = probabilities.dim(0)\n    # Sample index from probabilities, they must sum to 1\n    # get random value within (min, max) float32 range\n    var r = rand[DType.float32](1)\n    var cdf: Float32 = 0.0\n    for i in range(n):\n        cdf += probabilities[i]\n        if r[0] < cdf:\n            return i\n    return n - 1  # In case of rounding errors\n", "input": "This function takes a Tensor of float32 and returns an integer. It is declared the value n stating the number for sampling. Then the variable r is defined as a random value within (min, max) float32 range and cdf will accumulate the propabilities of the input tensor. If the loop completes without returning (which might occur due to rounding errors in floating-point addition), the function defaults to returning n - 1, the last index. This is a safety net to ensure the function always returns a valid index."}, {"output": "from time import now\r\n\r\nfrom algorithm import sum\r\nfrom benchmark import Unit, benchmark, keep\r\nfrom buffer import Buffer\r\nfrom tensor import Tensor\r\nfrom python import Python\r\nfrom tensor import rand\r\n\r\n# Change these numbers to reduce on different sizes\r\nalias size_small: Int = 1 << 21\r\nalias size_large: Int = 1 << 27\r\n\r\n# Datatype for Tensor/Array\r\nalias type = DType.float32\r\n\r\n\r\n# Use the https://en.wikipedia.org/wiki/Kahan_summation_algorithm\r\n# Simple summation of the array elements\r\nfn naive_reduce_sum[size: Int](array: Tensor[type]) -> Float32:\r\n    var A = array\r\n    var my_sum = array[0]\r\n    var c: Float32 = 0.0\r\n    for i in range(array.dim(0)):\r\n        var y = array[i] - c\r\n        var t = my_sum + y\r\n        c = (t - my_sum) - y\r\n        my_sum = t\r\n    return my_sum\r\n\r\n\r\nfn stdlib_reduce_sum[size: Int](array: Tensor[type]) -> Float32:\r\n    var my_sum = sum(array._to_buffer())\r\n    return my_sum\r\n\r\n\r\nfn pretty_print(name: StringLiteral, elements: Int, time: Float64) raises:\r\n    var py = Python.import_module(\"builtins\")\r\n    _ = py.print(\r\n        py.str(\"{:<16} {:>11,} {:>8.2f}ms\").format(\r\n            String(name) + \" elements:\", elements, time\r\n        )\r\n    )\r\n\r\n\r\nfn bench[\r\n    func: fn[size: Int] (array: Tensor[type]) -> Float32,\r\n    size: Int,\r\n    name: StringLiteral,\r\n](array: Tensor[type]) raises:\r\n    @parameter\r\n    fn runner():\r\n        var result = func[size](array)\r\n        keep(result)\r\n\r\n    var ms = benchmark.run[runner](max_runtime_secs=0.5).mean(Unit.ms)\r\n    pretty_print(name, size, ms)\r\n\r\n\r\nfn main() raises:\r\n    print(\r\n        \"Sum all values in a small array and large array\\n\"\r\n        \"Shows algorithm.sum from stdlib with much better performance\\n\"\r\n    )\r\n    # Create two 1-dimensional tensors i.e. arrays\r\n    var small_array = rand[type](size_small)\r\n    var large_array = rand[type](size_large)\r\n\r\n    bench[naive_reduce_sum, size_small, \"naive\"](small_array)\r\n    bench[naive_reduce_sum, size_large, \"naive\"](large_array)\r\n\r\n    bench[stdlib_reduce_sum, size_small, \"stdlib\"](small_array)\r\n    # CHECK: stdlib elements\r\n    bench[stdlib_reduce_sum, size_large, \"stdlib\"](large_array)", "input": "This sample implements a simple reduction operation on a\nLarge array of values to produce a single result.\nReductions and scans are common algorithm patterns in parallel computing."}, {"output": "\r\nfn naive_reduce_sum[size: Int](array: Tensor[type]) -> Float32:\r\n    var A = array\r\n    var my_sum = array[0]\r\n    var c: Float32 = 0.0\r\n    for i in range(array.dim(0)):\r\n        var y = array[i] - c\r\n        var t = my_sum + y\r\n        c = (t - my_sum) - y\r\n        my_sum = t\r\n    return my_sum", "input": "Use the https://en.wikipedia.org/wiki/Kahan_summation_algorithm\nSimple summation of the array elements"}, {"output": "from sys.info import *\r\nfrom sys.info import _current_cpu, _current_target, _triple_attr\r\n\r\n\r\ndef main():\r\n    var os = \"\"\r\n    if os_is_linux():\r\n        os = \"linux\"\r\n    elif os_is_macos():\r\n        os = \"macOS\"\r\n    else:\r\n        os = \"windows\"\r\n    var cpu = String(_current_cpu())\r\n    var arch = String(_triple_attr())\r\n    var cpu_features = String(\"\")\r\n    if has_sse4():\r\n        cpu_features += \" sse4\"\r\n    if has_avx():\r\n        cpu_features += \" avx\"\r\n    if has_avx2():\r\n        cpu_features += \" avx2\"\r\n    if has_avx512f():\r\n        cpu_features += \" avx512f\"\r\n    if has_vnni():\r\n        if has_avx512f():\r\n            cpu_features += \" avx512_vnni\"\r\n        else:\r\n            cpu_features += \" avx_vnni\"\r\n    if has_intel_amx():\r\n        cpu_features += \" intel_amx\"\r\n    if has_neon():\r\n        cpu_features += \" neon\"\r\n    if is_apple_m1():\r\n        cpu_features += \" Apple M1\"\r\n    if is_apple_m2():\r\n        cpu_features += \" Apple M2\"\r\n    if is_apple_m3():\r\n        cpu_features += \" Apple M3\"\r\n\r\n    print(\"System information: \")\r\n    print(\"    OS             : \", os)\r\n    print(\"    CPU            : \", cpu)\r\n    print(\"    Arch           : \", arch)\r\n    print(\"    Physical Cores : \", num_physical_cores())\r\n    print(\"    Logical Cores  : \", num_logical_cores())\r\n    # CHECK: CPU Features\r\n    print(\"    CPU Features   :\", cpu_features)", "input": "This sample prints the current host system information using APIs from the sys module."}, {"output": "from math import sqrt\r\nfrom benchmark import run, keep\r\nfrom collections import List\r\nfrom testing import assert_almost_equal\r\n\r\nalias PI = 3.141592653589793\r\nalias SOLAR_MASS = 4 * PI * PI\r\nalias DAYS_PER_YEAR = 365.24\r\n\r\n\r\n@value\r\nstruct Planet:\r\n    var pos: SIMD[DType.float64, 4]\r\n    var velocity: SIMD[DType.float64, 4]\r\n    var mass: Float64\r\n\r\n    fn __init__(\r\n        inout self,\r\n        pos: SIMD[DType.float64, 4],\r\n        velocity: SIMD[DType.float64, 4],\r\n        mass: Float64,\r\n    ):\r\n        self.pos = pos\r\n        self.velocity = velocity\r\n        self.mass = mass\r\n\r\n\r\nalias Sun = Planet(\r\n    0,\r\n    0,\r\n    SOLAR_MASS,\r\n)\r\n\r\nalias Jupiter = Planet(\r\n    SIMD[DType.float64, 4](\r\n        4.84143144246472090e00,\r\n        -1.16032004402742839e00,\r\n        -1.03622044471123109e-01,\r\n        0,\r\n    ),\r\n    SIMD[DType.float64, 4](\r\n        1.66007664274403694e-03 * DAYS_PER_YEAR,\r\n        7.69901118419740425e-03 * DAYS_PER_YEAR,\r\n        -6.90460016972063023e-05 * DAYS_PER_YEAR,\r\n        0,\r\n    ),\r\n    9.54791938424326609e-04 * SOLAR_MASS,\r\n)\r\n\r\nalias Saturn = Planet(\r\n    SIMD[DType.float64, 4](\r\n        8.34336671824457987e00,\r\n        4.12479856412430479e00,\r\n        -4.03523417114321381e-01,\r\n        0,\r\n    ),\r\n    SIMD[DType.float64, 4](\r\n        -2.76742510726862411e-03 * DAYS_PER_YEAR,\r\n        4.99852801234917238e-03 * DAYS_PER_YEAR,\r\n        2.30417297573763929e-05 * DAYS_PER_YEAR,\r\n        0,\r\n    ),\r\n    2.85885980666130812e-04 * SOLAR_MASS,\r\n)\r\n\r\nalias Uranus = Planet(\r\n    SIMD[DType.float64, 4](\r\n        1.28943695621391310e01,\r\n        -1.51111514016986312e01,\r\n        -2.23307578892655734e-01,\r\n        0,\r\n    ),\r\n    SIMD[DType.float64, 4](\r\n        2.96460137564761618e-03 * DAYS_PER_YEAR,\r\n        2.37847173959480950e-03 * DAYS_PER_YEAR,\r\n        -2.96589568540237556e-05 * DAYS_PER_YEAR,\r\n        0,\r\n    ),\r\n    4.36624404335156298e-05 * SOLAR_MASS,\r\n)\r\n\r\nalias Neptune = Planet(\r\n    SIMD[DType.float64, 4](\r\n        1.53796971148509165e01,\r\n        -2.59193146099879641e01,\r\n        1.79258772950371181e-01,\r\n        0,\r\n    ),\r\n    SIMD[DType.float64, 4](\r\n        2.68067772490389322e-03 * DAYS_PER_YEAR,\r\n        1.62824170038242295e-03 * DAYS_PER_YEAR,\r\n        -9.51592254519715870e-05 * DAYS_PER_YEAR,\r\n        0,\r\n    ),\r\n    5.15138902046611451e-05 * SOLAR_MASS,\r\n)\r\n\r\nalias INITIAL_SYSTEM = List[Planet](Sun, Jupiter, Saturn, Uranus, Neptune)\r\n\r\n\r\n@always_inline\r\nfn offset_momentum(inout bodies: List[Planet]):\r\n    var p = SIMD[DType.float64, 4]()\r\n\r\n    for body in bodies:\r\n        p += body[].velocity * body[].mass\r\n\r\n    var body = bodies[0]\r\n    body.velocity = -p / SOLAR_MASS\r\n\r\n    bodies[0] = body\r\n\r\n\r\n@always_inline\r\nfn advance(inout bodies: List[Planet], dt: Float64):\r\n    for i in range(len(INITIAL_SYSTEM)):\r\n        for j in range(len(INITIAL_SYSTEM) - i - 1):\r\n            var body_i = bodies[i]\r\n            var body_j = bodies[j + i + 1]\r\n            var diff = body_i.pos - body_j.pos\r\n            var diff_sqr = (diff * diff).reduce_add()\r\n            var mag = dt / (diff_sqr * sqrt(diff_sqr))\r\n\r\n            body_i.velocity -= diff * body_j.mass * mag\r\n            body_j.velocity += diff * body_i.mass * mag\r\n\r\n            bodies[i] = body_i\r\n            bodies[j + i + 1] = body_j\r\n\r\n    for body in bodies:\r\n        body[].pos += dt * body[].velocity\r\n\r\n\r\n@always_inline\r\nfn energy(bodies: List[Planet]) -> Float64:\r\n    var e: Float64 = 0\r\n\r\n    for i in range(len(INITIAL_SYSTEM)):\r\n        var body_i = bodies[i]\r\n        e += (\r\n            0.5\r\n            * body_i.mass\r\n            * ((body_i.velocity * body_i.velocity).reduce_add())\r\n        )\r\n        for j in range(len(INITIAL_SYSTEM) - i - 1):\r\n            var body_j = bodies[j + i + 1]\r\n            var diff = body_i.pos - body_j.pos\r\n            var distance = sqrt((diff * diff).reduce_add())\r\n            e -= (body_i.mass * body_j.mass) / distance\r\n\r\n    return e\r\n\r\n\r\ndef run_system():\r\n    print(\"Starting nbody...\")\r\n\r\n    var system = INITIAL_SYSTEM\r\n    offset_momentum(system)\r\n\r\n    print(\"Energy of System:\", energy(system))\r\n\r\n    for i in range(50_000_000):\r\n        advance(system, 0.01)\r\n\r\n    var system_energy = energy(system)\r\n    assert_almost_equal(system_energy, -0.1690599)\r\n    print(\"Energy of System:\", system_energy)\r\n\r\n\r\ndef benchmark():\r\n    fn benchmark_fn():\r\n        var system = INITIAL_SYSTEM\r\n        offset_momentum(system)\r\n        keep(energy(system))\r\n\r\n        for i in range(50_000_000):\r\n            advance(system, 0.01)\r\n\r\n        keep(energy(system))\r\n\r\n    run[benchmark_fn](max_runtime_secs=0.5).print()\r\n\r\n\r\ndef main():\r\n    run_system()", "input": "This sample implements the nbody benchmarking in\r\nhttps://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/nbody.html\r\n"}, {"output": "@always_inline(\"nodebug\")\r\nfn _digits[type: DType]() -> Int:\r\n\r\n    alias mlir_type = __mlir_type[`!pop.scalar<`, type.value, `>`]\r\n\r\n    @parameter\r\n    if type == DType.bool:\r\n        return 1\r\n\r\n    @parameter\r\n    if type.is_integral():\r\n        var bitwidth = bitwidthof[mlir_type]()\r\n        return bitwidth - 1 if type.is_signed() else bitwidth\r\n\r\n    @parameter\r\n    if type == DType.float16:\r\n        return 11\r\n\r\n    @parameter\r\n    if type == DType.bfloat16:\r\n        return 8\r\n\r\n    @parameter\r\n    if type == DType.float32:\r\n        return 24\r\n\r\n    @parameter\r\n    if type == DType.float64:\r\n        return 53\r\n    # Unreachable.\r\n    return -1", "input": "Returns the number of digits in base-radix that can be represented by\n    the type without change.\n\n    For integer types, this is the number of bits not counting the sign bit and\n    the padding bits (if any). For floating-point types, this is the digits of\n    the mantissa (for IEC 559/IEEE 754 implementations, this is the number of\n    digits stored for the mantissa plus one, because the mantissa has an\n    implicit leading 1 and binary point).\n\n    Parameters:\n        type: The type to get the digits for.\n\n    Returns:\n        The number of digits that can be represented by the type without change.\n"}, {"output": "@always_inline\r\nfn _fp_bitcast_to_integer[type: DType](value: Scalar[type]) -> Int:\r\n\r\n    alias integer_type = _integral_type_of[type]()\r\n    return int(bitcast[integer_type, 1](value))\r\n", "input": "Bitcasts the floating-point value to an integer.\r\n\r\n    Parameters:\r\n        type: The floating-point type.\r\n\r\n    Args:\r\n        value: The value to bitcast.\r\n\r\n    Returns:\r\n        An integer representation of the floating-point value.\r\n "}, {"output": "@always_inline\r\nfn _fp_bitcast_from_integer[type: DType](value: Int) -> Scalar[type]:\r\n\r\n    alias integer_type = _integral_type_of[type]()\r\n    var int_val = SIMD[integer_type, 1](value)\r\n    return bitcast[type, 1](int_val)", "input": "Bitcasts the integer value to a floating-point value.\r\n\r\n    Parameters:\r\n        type: The floating-point type.\r\n\r\n    Args:\r\n        value: The value to bitcast.\r\n\r\n    Returns:\r\n        A float-point representation of the integer value."}, {"output": " @staticmethod\r\n    @always_inline(\"nodebug\")\r\n    fn max_exponent() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n\r\n        @parameter\r\n        if type == DType.float16:\r\n            return 16\r\n        elif type == DType.float32 or type == DType.bfloat16:\r\n            return 128\r\n\r\n        debug_assert(type == DType.float64, \"must be float64\")\r\n        return 1024\r\n", "input": "Returns the max exponent of a floating point type.\n\n"}, {"output": " @staticmethod\r\n    @always_inline(\"nodebug\")\r\n    fn exponent_width() -> Int:\r\n        \r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n\r\n        @parameter\r\n        if type == DType.float16:\r\n            return 5\r\n        elif type == DType.float32 or type == DType.bfloat16:\r\n            return 8\r\n\r\n        debug_assert(type == DType.float64, \"must be float64\")\r\n        return 11\r\n", "input": "Returns the exponent width of a floating point type.\r\n\r\n "}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn mantissa_mask() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return (1 << Self.mantissa_width()) - 1", "input": "Returns the mantissa mask of a floating point type.\r\n"}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn exponent_bias() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return Self.max_exponent() - 1", "input": "Returns the exponent bias of a floating point type."}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn sign_mask() -> Int:\r\n\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return 1 << (Self.exponent_width() + Self.mantissa_width())", "input": "Returns the sign mask of a floating point type. It is computed by\r\n        `1 << (exponent_width + mantissa_mask)`."}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn exponent_mantissa_mask() -> Int:\r\n\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return Self.exponent_mask() + Self.mantissa_mask()", "input": "Returns the exponent and mantissa mask of a floating point type. It is\r\n        computed by `exponent_mask + mantissa_mask`."}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn quiet_nan_mask() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        var mantissa_width_val = Self.mantissa_width()\r\n        return (1 << Self.exponent_width() - 1) << mantissa_width_val + (\r\n            1 << (mantissa_width_val - 1)\r\n        )", "input": "Returns the quiet NaN mask for a floating point type.\r\n\r\n        The mask is defined by evaluating:\r\n\r\n        ```\r\n        (1<<exponent_width-1)<<mantissa_width + 1<<(mantissa_width-1)\r\n        ```\r\n\r\n        Returns:\r\n            The quiet NaN mask.\r\n"}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn bitcast_to_integer(value: Scalar[type]) -> Int:\r\n\r\n        return _fp_bitcast_to_integer[type](value)", "input": "Bitcasts the floating-point value to an integer.\r\n\r\n        Args:\r\n            value: The floating-point type.\r\n\r\n        Returns:\r\n            An integer representation of the floating-point value.\r\n    "}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn bitcast_from_integer(value: Int) -> Scalar[type]:\r\n\r\n        return _fp_bitcast_from_integer[type](value)", "input": "Bitcasts the floating-point value from an integer.\r\n\r\n        Args:\r\n            value: The int value.\r\n\r\n        Returns:\r\n            An floating-point representation of the Int.\r\n       "}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn get_sign(value: Scalar[type]) -> Bool:\r\n\r\n\r\n        return (Self.bitcast_to_integer(value) & Self.sign_mask()) != 0", "input": "Returns the sign of the floating point value. True if the sign is set\r\n        and False otherwise.\r\n\r\n        Args:\r\n            value: The floating-point type.\r\n\r\n        Returns:\r\n            Returns True if the sign is set and False otherwise.\r\n "}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn set_sign(value: Scalar[type], sign: Bool) -> Scalar[type]:\r\n\r\n        var bits = Self.bitcast_to_integer(value)\r\n        var sign_bits = Self.sign_mask()\r\n        bits &= ~sign_bits\r\n        if sign:\r\n            bits |= sign_bits\r\n        return Self.bitcast_from_integer(bits)", "input": "Sets the sign of the floating point value.\n\n        Args:\n            value: The floating-point value.\n            sign: True to set the sign and false otherwise.\n\n        Returns:\n            Returns the floating point value with the sign set.\n    "}, {"output": "    @staticmethod\r\n    @always_inline\r\n    fn get_exponent_without_bias(value: Scalar[type]) -> Int:\r\n\r\n\r\n        return Self.get_exponent(value) - Self.exponent_bias()", "input": "Returns the exponent bits of the floating-point value.\r\n\r\n        Args:\r\n            value: The floating-point value.\r\n\r\n        Returns:\r\n            Returns the exponent bits.\r\n       "}, {"output": "    @staticmethod\n    @always_inline\n    fn set_exponent(value: Scalar[type], exponent: Int) -> Scalar[type]:\n\n        var bits = Self.bitcast_to_integer(value)\n        bits &= ~Self.exponent_mask()\n        bits |= (exponent << Self.mantissa_width()) & Self.exponent_mask()\n        return Self.bitcast_from_integer(bits)", "input": "Sets the exponent bits of the floating-point value.\r\n\r\n        Args:\r\n            value: The floating-point value.\r\n            exponent: The exponent bits.\r\n\r\n        Returns:\r\n            Returns the floating-point value with the exponent bits set.\r\n        "}, {"output": "@always_inline(\"nodebug\")\r\nfn isinf[\r\n    type: DType, simd_width: Int\r\n](val: SIMD[type, simd_width]) -> SIMD[DType.bool, simd_width]:\r\n\r\n\r\n    @parameter\r\n    if not type.is_floating_point():\r\n        return False\r\n\r\n    alias negative_infinity_test: UInt32 = 0x0004\r\n    alias positive_infinity_test: UInt32 = 0x0200\r\n    return llvm_intrinsic[\"llvm.is.fpclass\", SIMD[DType.bool, simd_width]](\r\n        val.value, (negative_infinity_test | positive_infinity_test).value\r\n    )", "input": "Checks if the value is infinite.\r\n\r\n    This is always False for non-FP data types.\r\n\r\n    Parameters:\r\n        type: The value dtype.\r\n        simd_width: The width of the SIMD vector.\r\n\r\n    Args:\r\n        val: The value to check.\r\n\r\n    Returns:\r\n        True if val is infinite and False otherwise.\r\n   "}, {"output": "@always_inline(\"nodebug\")\r\nfn isnan[\r\n    type: DType, simd_width: Int\r\n](val: SIMD[type, simd_width]) -> SIMD[DType.bool, simd_width]:\r\n\r\n\r\n    @parameter\r\n    if not type.is_floating_point():\r\n        return False\r\n\r\n    @parameter\r\n    if type == DType.bfloat16:\r\n        alias int_dtype = _integral_type_of[type]()\r\n        var int_val = bitcast[int_dtype, simd_width](val)\r\n        return int_val & SIMD[int_dtype, simd_width](0x7FFF) > SIMD[\r\n            int_dtype, simd_width\r\n        ](0x7F80)\r\n\r\n    alias signaling_nan_test: UInt32 = 0x0001\r\n    alias quiet_nan_test: UInt32 = 0x0002\r\n    return llvm_intrinsic[\"llvm.is.fpclass\", SIMD[DType.bool, simd_width]](\r\n        val.value, (signaling_nan_test | quiet_nan_test).value\r\n    )\r\n", "input": "Checks if the value is Not a Number (NaN).\r\n\r\n    Parameters:\r\n        type: The value dtype.\r\n        simd_width: The width of the SIMD vector.\r\n\r\n    Args:\r\n        val: The value to check.\r\n\r\n    Returns:\r\n        True if val is NaN and False otherwise.\r\n"}, {"output": "@always_inline\nfn _reduce_and_fn(a: Bool, b: Bool) -> Bool:\n\n    return a and b", "input": "Performs AND operation on two boolean inputs.\r\n\r\n    Args:\r\n        a: The first boolean input.\r\n        b: The second boolean input.\r\n\r\n    Returns:\r\n        The result of AND operation on the inputs.\r\n "}, {"output": "@always_inline\r\nfn _int_tuple_binary_apply[\r\n    size: Int,\r\n    binary_fn: fn (Int, Int) -> Int,\r\n](a: StaticTuple[Int, size], b: StaticTuple[Int, size]) -> StaticTuple[\r\n    Int, size\r\n]:\r\n\r\n\r\n    var c = StaticTuple[Int, size]()\r\n\r\n    @always_inline\r\n    @parameter\r\n    fn do_apply[idx: Int]():\r\n        var a_elem: Int = a.__getitem__[idx]()\r\n        var b_elem: Int = b.__getitem__[idx]()\r\n        c.__setitem__[idx](binary_fn(a_elem, b_elem))\r\n\r\n    unroll[do_apply, size]()\r\n\r\n    return c", "input": "Applies a given element binary function to each pair of corresponding\r\n    elements in two tuples.\r\n\r\n    Example Usage:\r\n        var a: StaticTuple[Int, size]\r\n        var b: StaticTuple[Int, size]\r\n        var c = _int_tuple_binary_apply[size, Int.add](a, b)\r\n\r\n    Parameters:\r\n        size: Static size of the operand and result tuples.\r\n        binary_fn: Binary function to apply to tuple elements.\r\n\r\n    Args:\r\n        a: Tuple containing lhs operands of the elementwise binary function.\r\n        b: Tuple containing rhs operands of the elementwise binary function.\r\n\r\n    Returns:\r\n        Tuple containing the result.\r\n "}, {"output": "@always_inline\r\nfn _int_tuple_compare[\r\n    size: Int,\r\n    comp_fn: fn (Int, Int) -> Bool,\r\n](a: StaticTuple[Int, size], b: StaticTuple[Int, size]) -> StaticTuple[\r\n    mlir_bool,\r\n    size,\r\n]:\r\n\r\n\r\n    var c = StaticTuple[mlir_bool, size]()\r\n\r\n    @always_inline\r\n    @parameter\r\n    fn do_compare[idx: Int]():\r\n        var a_elem: Int = a.__getitem__[idx]()\r\n        var b_elem: Int = b.__getitem__[idx]()\r\n        c.__setitem__[idx](comp_fn(a_elem, b_elem).value)\r\n\r\n    unroll[do_compare, size]()\r\n\r\n    return c\r\n", "input": "Applies a given element compare function to each pair of corresponding\r\n    elements in two tuples and produces a tuple of Bools containing result.\r\n\r\n    Example Usage:\r\n        var a: StaticTuple[Int, size]\r\n        var b: StaticTuple[Int, size]\r\n        var c = _int_tuple_compare[size, Int.less_than](a, b)\r\n\r\n    Parameters:\r\n        size: Static size of the operand and result tuples.\r\n        comp_fn: Compare function to apply to tuple elements.\r\n\r\n    Args:\r\n        a: Tuple containing lhs operands of the elementwise compare function.\r\n        b: Tuple containing rhs operands of the elementwise compare function.\r\n\r\n    Returns:\r\n        Tuple containing the result.\r\n   "}, {"output": " @always_inline\n    fn __init__() -> Self:\n\n        return 0\n", "input": "Constructs a static int tuple of the given size.\r\n\r\n        Returns:\r\n            The constructed tuple.\r\n       "}, {"output": "    @always_inline\r\n    fn __init__(value: __mlir_type.index) -> Self:\r\n\r\n        constrained[size == 1]()\r\n        return Int(value)", "input": "       Constructs a sized 1 static int tuple of given the element value.\r\n\r\n        Args:\r\n            value: The initial value.\r\n\r\n        Returns:\r\n            The constructed tuple.\r\n       "}, {"output": " @always_inline\r\n    fn __init__(elems: Tuple[Int, Int]) -> Self:\r\n\r\n\r\n        var num_elements = len(elems)\r\n\r\n        debug_assert(\r\n            size == num_elements,\r\n            \"[StaticIntTuple] mismatch in the number of elements\",\r\n        )\r\n\r\n        var tup = Self()\r\n\r\n        @parameter\r\n        fn fill[idx: Int]():\r\n            tup[idx] = elems.get[idx, Int]()\r\n\r\n        unroll[fill, 2]()\r\n\r\n        return tup", "input": "Constructs a static int tuple given a tuple of integers.\r\n\r\n        Args:\r\n            elems: The tuple to copy from.\r\n\r\n        Returns:\r\n            The constructed tuple.\r\n        "}, {"output": "@always_inline\r\n    fn __init__(elems: Tuple[Int, Int, Int, Int]) -> Self:\r\n\r\n\r\n        var num_elements = len(elems)\r\n\r\n        debug_assert(\r\n            size == num_elements,\r\n            \"[StaticIntTuple] mismatch in the number of elements\",\r\n        )\r\n\r\n        var tup = Self()\r\n\r\n        @parameter\r\n        fn fill[idx: Int]():\r\n            tup[idx] = elems.get[idx, Int]()\r\n\r\n        unroll[fill, 4]()\r\n\r\n        return tup\r\n", "input": "Constructs a static int tuple given a tuple of integers.\r\n\r\n        Args:\r\n            elems: The tuple to copy from.\r\n\r\n        Returns:\r\n            The constructed tuple.\r\n        "}, {"output": "@always_inline\nfn Index[\n    T0: Intable, T1: Intable, T2: Intable\n](x: T0, y: T1, z: T2) -> StaticIntTuple[3]:\n\n    return StaticIntTuple[3](int(x), int(y), int(z))", "input": "Constructs a 3-D Index from the given values.\r\n\r\n    Parameters:\r\n        T0: The type of the 1st argument.\r\n        T1: The type of the 2nd argument.\r\n        T2: The type of the 3rd argument.\r\n\r\n    Args:\r\n        x: The 1st initial value.\r\n        y: The 2nd initial value.\r\n        z: The 3nd initial value.\r\n\r\n    Returns:\r\n        The constructed StaticIntTuple.\r\n    "}, {"output": "@always_inline\nfn Index[\n    T0: Intable, T1: Intable, T2: Intable, T3: Intable\n](x: T0, y: T1, z: T2, w: T3) -> StaticIntTuple[4]:\n\n    return StaticIntTuple[4](int(x), int(y), int(z), int(w))", "input": "Constructs a 4-D Index from the given values.\n\n    Parameters:\n        T0: The type of the 1st argument.\n        T1: The type of the 2nd argument.\n        T2: The type of the 3rd argument.\n        T3: The type of the 4th argument.\n\n    Args:\n        x: The 1st initial value.\n        y: The 2nd initial value.\n        z: The 3nd initial value.\n        w: The 4th initial value.\n\n    Returns:\n        The constructed StaticIntTuple.\n"}, {"output": "@always_inline\r\nfn Index[\r\n    T0: Intable, T1: Intable, T2: Intable, T3: Intable, T4: Intable\r\n](x: T0, y: T1, z: T2, w: T3, v: T4) -> StaticIntTuple[5]:\r\n\r\n    return StaticIntTuple[5](int(x), int(y), int(z), int(w), int(v))", "input": "Constructs a 5-D Index from the given values.\r\n\r\n    Parameters:\r\n        T0: The type of the 1st argument.\r\n        T1: The type of the 2nd argument.\r\n        T2: The type of the 3rd argument.\r\n        T3: The type of the 4th argument.\r\n        T4: The type of the 5th argument.\r\n\r\n    Args:\r\n        x: The 1st initial value.\r\n        y: The 2nd initial value.\r\n        z: The 3nd initial value.\r\n        w: The 4th initial value.\r\n        v: The 5th initial value.\r\n\r\n    Returns:\r\n        The constructed StaticIntTuple.\r\n    "}, {"output": "@always_inline\r\nfn now() -> Int:\r\n\r\n    return _monotonic_nanoseconds()\r\n", "input": "Returns the current monotonic time time in nanoseconds. This function\r\n    queries the current platform's monotonic clock, making it useful for\r\n    measuring time differences, but the significance of the returned value\r\n    varies depending on the underlying implementation.\r\n\r\n    Returns:\r\n        The current time in ns.\r\n    "}, {"output": "@always_inline\r\n@parameter\r\nfn _time_function_windows[func: fn () capturing -> None]() -> Int:\r\n\r\n\r\n    var ticks_per_sec: _WINDOWS_LARGE_INTEGER = 0\r\n    var ticks_per_sec_ptr = Pointer[_WINDOWS_LARGE_INTEGER].address_of(\r\n        ticks_per_sec\r\n    )\r\n    external_call[\"QueryPerformanceFrequency\", NoneType](ticks_per_sec_ptr)\r\n\r\n    var starting_tick_count: _WINDOWS_LARGE_INTEGER = 0\r\n    var start_ptr = Pointer[_WINDOWS_LARGE_INTEGER].address_of(\r\n        starting_tick_count\r\n    )\r\n    var ending_tick_count: _WINDOWS_LARGE_INTEGER = 0\r\n    var end_ptr = Pointer[_WINDOWS_LARGE_INTEGER].address_of(ending_tick_count)\r\n\r\n    external_call[\"QueryPerformanceCounter\", NoneType](start_ptr)\r\n    func()\r\n    external_call[\"QueryPerformanceCounter\", NoneType](end_ptr)\r\n\r\n    var elapsed_ticks = ending_tick_count - starting_tick_count\r\n\r\n    # Note: Windows performance counter resolution is in \u00b5s.\r\n    var elapsed_time_in_ns = (elapsed_ticks * 1_000_000_000) // ticks_per_sec\r\n    return int(elapsed_time_in_ns)", "input": "Calculates elapsed time in Windows OS"}, {"output": "@always_inline\r\n@parameter\r\nfn time_function[func: fn () capturing -> None]() -> Int:\r\n\r\n\r\n    @parameter\r\n    if os_is_windows():\r\n        return _time_function_windows[func]()\r\n\r\n    var tic = now()\r\n    func()\r\n    var toc = now()\r\n    return toc - tic", "input": "Measures the time spent in the function.\r\n\r\n    Parameters:\r\n        func: The function to time.\r\n\r\n    Returns:\r\n        The time elapsed in the function in ns.\r\n   "}, {"output": "fn sleep(sec: Float64):\r\n\r\n    alias NANOSECONDS_IN_SECOND = 1_000_000_000\r\n    var total_secs = _floor(sec)\r\n    var tv_spec = _CTimeSpec(\r\n        int(total_secs.cast[DType.index]()),\r\n        int((sec - total_secs) * NANOSECONDS_IN_SECOND),\r\n    )\r\n    var req = Pointer[_CTimeSpec].address_of(tv_spec)\r\n    var rem = Pointer[_CTimeSpec].get_null()\r\n    _ = external_call[\"nanosleep\", Int32](req, rem)", "input": "Suspends the current thread for the seconds specified.\r\n\r\n    Args:\r\n        sec: The number of seconds to sleep for.\r\n   "}, {"output": "fn sleep(sec: Int):\r\n\r\n\r\n    @parameter\r\n    if os_is_windows():\r\n        # In Windows the argument is in milliseconds.\r\n        external_call[\"Sleep\", NoneType](sec * 1000)\r\n    else:\r\n        external_call[\"sleep\", NoneType](sec)", "input": "Suspends the current thread for the seconds specified.\r\n\r\n    Args:\r\n        sec: The number of seconds to sleep for.\r\n    "}, {"output": "fn b64encode(str: String) -> String:\r\n\r\n    alias lookup = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\r\n    var b64chars = lookup.data()\r\n\r\n    var length = len(str)\r\n    var out = List[Int8](capacity=length + 1)\r\n\r\n    @parameter\r\n    @always_inline\r\n    fn s(idx: Int) -> Int:\r\n        return int(str._buffer[idx])\r\n\r\n    # This algorithm is based on https://arxiv.org/abs/1704.00605\r\n    var end = length - (length % 3)\r\n    for i in range(0, end, 3):\r\n        var si = s(i)\r\n        var si_1 = s(i + 1)\r\n        var si_2 = s(i + 2)\r\n        out.append(b64chars.load(si // 4))\r\n        out.append(b64chars.load(((si * 16) % 64) + si_1 // 16))\r\n        out.append(b64chars.load(((si_1 * 4) % 64) + si_2 // 64))\r\n        out.append(b64chars.load(si_2 % 64))\r\n\r\n    var i = end\r\n    if i < length:\r\n        var si = s(i)\r\n        out.append(b64chars.load(si // 4))\r\n        if i == length - 1:\r\n            out.append(b64chars.load((si * 16) % 64))\r\n            out.append(ord(\"=\"))\r\n        elif i == length - 2:\r\n            var si_1 = s(i + 1)\r\n            out.append(b64chars.load(((si * 16) % 64) + si_1 // 16))\r\n            out.append(b64chars.load((si_1 * 4) % 64))\r\n        out.append(ord(\"=\"))\r\n    out.append(0)\r\n    return String(out ^)", "input": "Performs base64 encoding on the input string.\r\n\r\n    Args:\r\n      str: The input string.\r\n\r\n    Returns:\r\n      Base64 encoding of the input string.\r\n "}, {"output": "@value\r\nstruct _DictKeyIter[\r\n    K: KeyElement,\r\n    V: CollectionElement,\r\n    dict_mutability: __mlir_type.`i1`,\r\n    dict_lifetime: AnyLifetime[dict_mutability].type,\r\n]:\r\n\r\n\r\n    alias imm_dict_lifetime = __mlir_attr[\r\n        `#lit.lifetime.mutcast<`, dict_lifetime, `> : !lit.lifetime<1>`\r\n    ]\r\n    alias ref_type = Reference[K, __mlir_attr.`0: i1`, Self.imm_dict_lifetime]\r\n\r\n    var iter: _DictEntryIter[K, V, dict_mutability, dict_lifetime]\r\n\r\n    fn __iter__(self) -> Self:\r\n        return self\r\n\r\n    fn __next__(inout self) -> Self.ref_type:\r\n        var entry_ref = self.iter.__next__()\r\n        var mlir_ptr = __mlir_op.`lit.ref.to_pointer`(\r\n            Reference(entry_ref[].key).value\r\n        )\r\n        var key_ptr = AnyPointer[K] {\r\n            value: __mlir_op.`pop.pointer.bitcast`[\r\n                _type = AnyPointer[K].pointer_type\r\n            ](mlir_ptr)\r\n        }\r\n        return __mlir_op.`lit.ref.from_pointer`[\r\n            _type = Self.ref_type.mlir_ref_type\r\n        ](key_ptr.value)\r\n\r\n    fn __len__(self) -> Int:\r\n        return self.iter.__len__()", "input": "Iterator over immutable Dict key references.\r\n\r\n    Parameters:\r\n        K: The key type of the elements in the dictionary.\r\n        V: The value type of the elements in the dictionary.\r\n        dict_mutability: Whether the reference to the vector is mutable.\r\n        dict_lifetime: The lifetime of the List\r\n  "}, {"output": "@value\r\nstruct _DictValueIter[\r\n    K: KeyElement,\r\n    V: CollectionElement,\r\n    dict_mutability: __mlir_type.`i1`,\r\n    dict_lifetime: AnyLifetime[dict_mutability].type,\r\n]:\r\n\r\n\r\n    alias ref_type = Reference[V, dict_mutability, dict_lifetime]\r\n\r\n    var iter: _DictEntryIter[K, V, dict_mutability, dict_lifetime]\r\n\r\n    fn __iter__(self) -> Self:\r\n        return self\r\n\r\n    fn __next__(inout self) -> Self.ref_type:\r\n        var entry_ref = self.iter.__next__()\r\n        var mlir_ptr = __mlir_op.`lit.ref.to_pointer`(\r\n            Reference(entry_ref[].value).value\r\n        )\r\n        var value_ptr = AnyPointer[V] {\r\n            value: __mlir_op.`pop.pointer.bitcast`[\r\n                _type = AnyPointer[V].pointer_type\r\n            ](mlir_ptr)\r\n        }\r\n        return __mlir_op.`lit.ref.from_pointer`[\r\n            _type = Self.ref_type.mlir_ref_type\r\n        ](value_ptr.value)\r\n\r\n    fn __len__(self) -> Int:\r\n        return self.iter.__len__()", "input": "Iterator over Dict value references. These are mutable if the dict\r\n    is mutable.\r\n\r\n    Parameters:\r\n        K: The key type of the elements in the dictionary.\r\n        V: The value type of the elements in the dictionary.\r\n        dict_mutability: Whether the reference to the vector is mutable.\r\n        dict_lifetime: The lifetime of the List\r\n    "}, {"output": "@value\nstruct DictEntry[K: KeyElement, V: CollectionElement](CollectionElement):\n\n\n    var hash: Int\n    \"\"\"`key.__hash__()`, stored so hashing isn't re-computed during dict lookup.\"\"\"\n    var key: K\n    \"\"\"The unique key for the entry.\"\"\"\n    var value: V\n    \"\"\"The value associated with the key.\"\"\"\n\n    fn __init__(inout self, owned key: K, owned value: V):\n        \"\"\"Create an entry from a key and value, computing the hash.\n\n        Args:\n            key: The key of the entry.\n            value: The value of the entry.\n        \"\"\"\n        self.hash = hash(key)\n        self.key = key ^\n        self.value = value ^\n", "input": "Store a key-value pair entry inside a dictionary.\r\n\r\n    Parameters:\r\n        K: The key type of the dict. Must be Hashable+EqualityComparable.\r\n        V: The value type of the dict.\r\n   "}, {"output": "    fn __init__(inout self, reserved: Int):\n        if reserved <= 128:\n            var data = DTypePointer[DType.int8].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()\n        elif reserved <= 2**16 - 2:\n            var data = DTypePointer[DType.int16].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()\n        elif reserved <= 2**32 - 2:\n            var data = DTypePointer[DType.int32].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()\n        else:\n            var data = DTypePointer[DType.int64].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()", "input": "A constructor method that allocates a DTypePointer of size defined by the input reserved, which would represent values of type int8, int16, int32 or int64."}, {"output": "    fn copy(self, reserved: Int) -> Self:\r\n        var index = Self(reserved)\r\n        if reserved <= 128:\r\n            var data = self.data.bitcast[DType.int8]()\r\n            var new_data = index.data.bitcast[DType.int8]()\r\n            memcpy(new_data, data, reserved)\r\n        elif reserved <= 2**16 - 2:\r\n            var data = self.data.bitcast[DType.int16]()\r\n            var new_data = index.data.bitcast[DType.int16]()\r\n            memcpy(new_data, data, reserved)\r\n        elif reserved <= 2**32 - 2:\r\n            var data = self.data.bitcast[DType.int32]()\r\n            var new_data = index.data.bitcast[DType.int32]()\r\n            memcpy(new_data, data, reserved)\r\n        else:\r\n            var data = self.data.bitcast[DType.int64]()\r\n            var new_data = index.data.bitcast[DType.int64]()\r\n            memcpy(new_data, data, reserved)\r\n        return index ^", "input": "A method to create a copy of the object passed as argument and return it."}, {"output": "    fn get_index(self, reserved: Int, slot: Int) -> Int:\n        if reserved <= 128:\n            var data = self.data.bitcast[DType.int8]()\n            return data.load(slot % reserved).to_int()\n        elif reserved <= 2**16 - 2:\n            var data = self.data.bitcast[DType.int16]()\n            return data.load(slot % reserved).to_int()\n        elif reserved <= 2**32 - 2:\n            var data = self.data.bitcast[DType.int32]()\n            return data.load(slot % reserved).to_int()\n        else:\n            var data = self.data.bitcast[DType.int64]()\n            return data.load(slot % reserved).to_int()", "input": "This function is used to calculate the position of a given index in a data structure. The method has two integer arguments, reserved and slot. The self.data.bitcast[DType.int8]() is performing a bitcast operation on the data contained in self.data, converting it to an array of signed 8-bit integers (int8), and this is done as well for the 16 bit, 32 bit and 64 bit integers."}, {"output": "    fn set_index(inout self, reserved: Int, slot: Int, value: Int):\r\n        if reserved <= 128:\r\n            var data = self.data.bitcast[DType.int8]()\r\n            return data.store(slot % reserved, value)\r\n        elif reserved <= 2**16 - 2:\r\n            var data = self.data.bitcast[DType.int16]()\r\n            return data.store(slot % reserved, value)\r\n        elif reserved <= 2**32 - 2:\r\n            var data = self.data.bitcast[DType.int32]()\r\n            return data.store(slot % reserved, value)\r\n        else:\r\n            var data = self.data.bitcast[DType.int64]()\r\n            return data.store(slot % reserved, value)", "input": "The set_index function is designed to set a value in a data structure (self.data) at a specified index (slot). The choice of the data type to use for storing the value depends on the reserved parameter, which determines the maximum capacity of the data structure."}, {"output": "var size: Int", "input": "The number of elements currently stored in the dict."}, {"output": "var _n_entries: Int", "input": "\"The number of entries currently allocated.\""}, {"output": "var _reserved: Int", "input": "The current reserved size of the dictionary."}, {"output": "    fn __init__(inout self):\n\n        self.size = 0\n        self._n_entries = 0\n        self._reserved = 8\n        self._index = _DictIndex(self._reserved)\n        self._entries = Self._new_entries(self._reserved)", "input": "Initialize an empty dictiontary."}, {"output": "    fn __init__(inout self, existing: Self):\n\n        self.size = existing.size\n        self._n_entries = existing._n_entries\n        self._reserved = existing._reserved\n        self._index = existing._index.copy(existing._reserved)\n        self._entries = existing._entries", "input": "Copy an existing dictiontary.\r\n\r\n        Args:\r\n            existing: The existing dict.\r\n        "}, {"output": "    fn __copyinit__(inout self, existing: Self):\n\n        self.size = existing.size\n        self._n_entries = existing._n_entries\n        self._reserved = existing._reserved\n        self._index = existing._index.copy(existing._reserved)\n        self._entries = existing._entries", "input": "Copy an existing dictiontary.\r\n\r\n        Args:\r\n            existing: The existing dict.\r\n        "}, {"output": "    fn __moveinit__(inout self, owned existing: Self):\n\n        self.size = existing.size\n        self._n_entries = existing._n_entries\n        self._reserved = existing._reserved\n        self._index = existing._index ^\n        self._entries = existing._entries ^", "input": "Move data of an existing dict into a new one.\r\n\r\n        Args:\r\n            existing: The existing dict.\r\n        "}, {"output": "    fn __getitem__(self, key: K) raises -> V:\n\n        var value = self.find(key)\n        if value:\n            return value.value()\n        raise \"KeyError\"", "input": "Retrieve a value out of the dictionary.\r\n\r\n        Args:\r\n            key: The key to retrieve.\r\n\r\n        Returns:\r\n            The value associated with the key, if it's present.\r\n\r\n        Raises:\r\n            \"KeyError\" if the key isn't present.\r\n        "}, {"output": "    fn __setitem__(inout self, key: K, value: V):\r\n\r\n        self._insert(key, value)", "input": " Set a value in the dictionary by key.\r\n\r\n        Args:\r\n            key: The key to associate with the specified value.\r\n            value: The data to store in the dictionary.\r\n        "}, {"output": "    fn __contains__(self, key: K) -> Bool:\n\n        return self.find(key).__bool__()", "input": "Check if a given value is in the dictionary or not.\n\n        Args:\n            key: The key to check.\n\n        Returns:\n            True if there key exists in the dictionary, False otherwise.\r\n       "}, {"output": "    fn __len__(self) -> Int:\r\n       \r\n        return self.size", "input": "The number of elements currenly stored in the dictionary."}, {"output": "    fn find(self, key: K) -> Optional[V]:\r\n \r\n        var hash = hash(key)\r\n        var found: Bool\r\n        var slot: Int\r\n        var index: Int\r\n        found, slot, index = self._find_index(hash, key)\r\n        if found:\r\n            var ev = self._entries.__get_ref(index)[]\r\n            debug_assert(ev.__bool__(), \"entry in index must be full\")\r\n            return ev.value().value\r\n        return None", "input": "Find a value in the dictionary by key.\r\n\r\n        Args:\r\n            key: The key to search for in the dictionary.\r\n\r\n        Returns:\r\n            An optional value containing a copy of the value if it was present,\r\n            otherwise an empty Optional.\r\n        "}, {"output": "    fn pop(inout self, key: K, owned default: Optional[V] = None) raises -> V:\r\n \r\n        var hash = hash(key)\r\n        var found: Bool\r\n        var slot: Int\r\n        var index: Int\r\n        found, slot, index = self._find_index(hash, key)\r\n        if found:\r\n            self._set_index(slot, Self.REMOVED)\r\n            var entry = self._entries.__get_ref(index)[]\r\n            self._entries[index] = None\r\n            self.size -= 1\r\n            debug_assert(entry.__bool__(), \"entry in index must be full\")\r\n            return entry.value().value\r\n        elif default:\r\n            return default.value()\r\n        raise \"KeyError\"", "input": " Remove a value from the dictionary by key.\r\n\r\n        Args:\r\n            key: The key to remove from the dictionary.\r\n            default: Optionally provide a default value to return if the key\r\n                was not found instead of raising.\r\n\r\n        Returns:\r\n            The value associated with the key, if it was in the dictionary.\r\n            If it wasn't, return the provided default value instead.\r\n\r\n        Raises:\r\n            \"KeyError\" if the key was not present in the dictionary and no\r\n            default value was provided.\r\n       "}, {"output": "    fn __iter__[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _DictKeyIter[K, V, mutability, self_life]:\r\n\r\n        return _DictKeyIter(\r\n            _DictEntryIter[K, V, mutability, self_life](0, 0, Reference(self))\r\n        )", "input": "Iterate over the dict's keys as immutable references.\r\n\r\n        Parameters:\r\n            mutability: Whether the dict is mutable.\r\n            self_life: The dict's lifetime.\r\n\r\n        Returns:\r\n            An iterator of immutable references to the dictionary keys.\r\n        "}, {"output": "    fn keys[\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\n    ](\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\n    ) -> _DictKeyIter[K, V, mutability, self_life]:\n\n        return Self.__iter__(self)", "input": "Iterate over the dict's keys as immutable references.\r\n\r\n        Parameters:\r\n            mutability: Whether the dict is mutable.\r\n            self_life: The dict's lifetime.\r\n\r\n        Returns:\r\n            An iterator of immutable references to the dictionary keys.\r\n        "}, {"output": "    fn values[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _DictValueIter[K, V, mutability, self_life]:\r\n\r\n        return _DictValueIter(\r\n            _DictEntryIter[K, V, mutability, self_life](0, 0, Reference(self))\r\n        )", "input": "Iterate over the dict's values as references.\r\n\r\n        Parameters:\r\n            mutability: Whether the dict is mutable.\r\n            self_life: The dict's lifetime.\r\n\r\n        Returns:\r\n            An iterator of references to the dictionary values.\r\n        "}, {"output": "    fn items[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _DictEntryIter[K, V, mutability, self_life]:\r\n\r\n        return _DictEntryIter[K, V, mutability, self_life](\r\n            0, 0, Reference(self)\r\n        )", "input": "Iterate over the dict's entries as immutable references.\r\n\r\n        These can't yet be unpacked like Python dict items, but you can\r\n        access the key and value as attributes ie.\r\n\r\n        ```mojo\r\n        for e in dict.items():\r\n            print(e[].key, e[].value)\r\n        ```\r\n\r\n        Parameters:\r\n            mutability: Whether the dict is mutable.\r\n            self_life: The dict's lifetime.\r\n\r\n        Returns:\r\n            An iterator of immutable references to the dictionary entries.\r\n      "}, {"output": "    @staticmethod\r\n    fn _new_entries(reserved: Int) -> List[Optional[DictEntry[K, V]]]:\r\n        var entries = List[Optional[DictEntry[K, V]]](capacity=reserved)\r\n        for i in range(reserved):\r\n            entries.append(None)\r\n        return entries", "input": "Write a function called new_entries, which is a static method, that takes an integer as input and returns a list. "}, {"output": "    fn _insert(inout self, owned key: K, owned value: V):\r\n        self._insert(DictEntry[K, V](key ^, value ^))", "input": "A method to insert a key and a value to a dictionary structure."}, {"output": "    fn _insert(inout self, owned entry: DictEntry[K, V]):\r\n        self._maybe_resize()\r\n        var found: Bool\r\n        var slot: Int\r\n        var index: Int\r\n        found, slot, index = self._find_index(entry.hash, entry.key)\r\n\r\n        self._entries[index] = entry ^\r\n        if not found:\r\n            self._set_index(slot, index)\r\n            self.size += 1\r\n            self._n_entries += 1", "input": "The _insert method is responsible for inserting a dictionary entry into the data structure."}, {"output": "    fn _get_index(self, slot: Int) -> Int:\r\n        return self._index.get_index(self._reserved, slot)", "input": "A method that returns the index of a given slot."}, {"output": "    fn _set_index(inout self, slot: Int, index: Int):\n        return self._index.set_index(self._reserved, slot, index)", "input": "The _set_index function serves as a proxy method to set an index value within another data structure _index by calling its set_index method. Params _reserved: The maximum capacity of the data structure, necessary for determining the appropriate data type for storage.\r\nslot: The index where the value will be set within the _index data structure.\r\nindex: The integer value to be stored at the specified slot."}, {"output": "    fn _next_index_slot(self, inout slot: Int, inout perturb: Int):\r\n        alias PERTURB_SHIFT = 5\r\n        perturb >>= PERTURB_SHIFT\r\n        slot = ((5 * slot) + perturb + 1) % self._reserved", "input": "The _next_index_slot method is responsible for computing the next index slot within the data structure, considering the current slot and perturbation value."}, {"output": "    fn _find_empty_index(self, hash: Int) -> Int:\r\n        var slot = hash % self._reserved\r\n        var perturb = hash\r\n        for _ in range(self._reserved):\r\n            var index = self._get_index(slot)\r\n            if index == Self.EMPTY:\r\n                return slot\r\n            self._next_index_slot(slot, perturb)\r\n        abort(\"Dict: no empty index in _find_empty_index\")\r\n        return 0\r", "input": "The _find_empty_index method is responsible for locating an empty index within the data structure based on a given hash value. "}, {"output": "    fn _over_load_factor(self) -> Bool:\r\n        return 3 * self.size > 2 * self._reserved\r", "input": "An instance method that returns true if the data structure is more than 150% loaded."}, {"output": "    fn _over_compact_factor(self) -> Bool:\r\n        return 4 * self._n_entries > 3 * self._reserved", "input": "An instance method that returns a boolean value if the object's attribute _n_entries is greater than 3/4 of the reserved size of the structure."}, {"output": "    fn _maybe_resize(inout self):\n        if not self._over_load_factor():\n            if self._over_compact_factor():\n                self._compact()\n            return\n        self._reserved *= 2\n        self.size = 0\n        self._n_entries = 0\n        self._index = _DictIndex(self._reserved)\n        var old_entries = self._entries ^\n        self._entries = self._new_entries(self._reserved)\n\n        for i in range(len(old_entries)):\n            var entry = old_entries.__get_ref(i)[]\n            if entry:\n                self._insert(entry.value())", "input": "The _maybe_resize method is responsible for potentially resizing the data structure if it exceeds certain load or compact factors.The method first checks whether the load factor exceeds a certain threshold by calling the _over_load_factor method. If it doesn't, it proceeds to check the compact factor. If the load factor is acceptable but the compact factor is exceeded, it calls the _compact method to compact the data structure. If the load factor is exceeded, the method doubles the reserved capacity (self._reserved *= 2), effectively increasing the space available for entries. It resets the size and number of entries and it transfers the old data to the new entries."}, {"output": "    fn _compact(inout self):\n        self._index = _DictIndex(self._reserved)\n        var right = 0\n        for left in range(self.size):\n            while not self._entries.__get_ref(right)[]:\n                right += 1\n                debug_assert(right < self._reserved, \"Invalid dict state\")\n            var entry = self._entries.__get_ref(right)[]\n            debug_assert(entry.__bool__(), \"Logic error\")\n            var slot = self._find_empty_index(entry.value().hash)\n            self._set_index(slot, left)\n            if left != right:\n                self._entries[left] = entry\n                self._entries[right] = None\n\n        self._n_entries = self.size", "input": "The _compact method is responsible for compacting the data structure by removing any gaps caused by previously removed or overwritten entries. "}, {"output": "var data: AnyPointer[T]", "input": "The underlying storage for the list."}, {"output": "var size: Int", "input": "The number of elements in the list."}, {"output": "var capacity: Int", "input": "The amount of elements that can fit in the list without resizing it."}, {"output": "    fn __init__(inout self):\r\n       \r\n        self.data = AnyPointer[T]()\r\n        self.size = 0\r\n        self.capacity = 0", "input": "Constructs an empty list."}, {"output": "    fn __init__(inout self, existing: Self):\r\n\r\n        self.__init__(capacity=existing.capacity)\r\n        for e in existing:\r\n            self.append(e[])", "input": "Creates a deep copy of the given list.\r\n\r\n        Args:\r\n            existing: The list to copy.\r\n        "}, {"output": "    fn __init__(inout self, *, capacity: Int):\n\n        self.data = AnyPointer[T].alloc(capacity)\n        self.size = 0\n        self.capacity = capacity", "input": "Constructs a list with the given capacity.\r\n\r\n        Args:\r\n            capacity: The requested capacity of the list.\r\n        "}, {"output": "    fn __init__(inout self, *values: T):\r\n\r\n        self = Self(capacity=len(values))\r\n        for value in values:\r\n            self.append(value[])", "input": "Constructs a list from the given values.\r\n\r\n        Args:\r\n            values: The values to populate the list with."}, {"output": "    fn __moveinit__(inout self, owned existing: Self):\n \n        self.data = existing.data\n        self.size = existing.size\n        self.capacity = existing.capacity", "input": "Move data of an existing list into a new one.\r\n\r\n        Args:\r\n            existing: The existing list.\r\n"}, {"output": "    fn __copyinit__(inout self, existing: Self):\r\n\r\n        self = Self(capacity=existing.capacity)\r\n        for i in range(len(existing)):\r\n            self.append(existing[i])", "input": "Creates a deepcopy of the given list.\r\n\r\n        Args:\r\n            existing: The list to copy.\r\n"}, {"output": "    fn __del__(owned self):\r\n\r\n        for i in range(self.size):\r\n            _ = (self.data + i).take_value()\r\n        if self.data:\r\n            self.data.free()", "input": "Destroy all elements in the list and free its memory."}, {"output": "    fn __len__(self) -> Int:\r\n\r\n        return self.size", "input": "Gets the number of elements in the list.\r\n\r\n        Returns:\r\n            The number of elements in the list.\r\n        "}, {"output": "    fn _realloc(inout self, new_capacity: Int):\r\n        var new_data = AnyPointer[T].alloc(new_capacity)\r\n\r\n        for i in range(self.size):\r\n            (new_data + i).emplace_value((self.data + i).take_value())\r\n\r\n        if self.data:\r\n            self.data.free()\r\n        self.data = new_data\r\n        self.capacity = new_capacity", "input": "he _realloc method is responsible for reallocating memory for the data structure to accommodate a new capacity. "}, {"output": "    fn append(inout self, owned value: T):\r\n\r\n        if self.size >= self.capacity:\r\n            self._realloc(_max(1, self.capacity * 2))\r\n        (self.data + self.size).emplace_value(value ^)\r\n        self.size += 1", "input": "Appends a value to this list.\r\n\r\n        Args:\r\n            value: The value to append.\r\n"}, {"output": "    fn pop_back(inout self) -> T:\r\n\r\n        var ret_val = (self.data + (self.size - 1)).take_value()\r\n        self.size -= 1\r\n        if self.size * 4 < self.capacity:\r\n            if self.capacity > 1:\r\n                self._realloc(self.capacity // 2)\r\n        return ret_val ^", "input": "Pops a value from the back of this list.\r\n\r\n        Returns:\r\n            The popped value.\r\n"}, {"output": "    fn reserve(inout self, new_capacity: Int):\r\n\r\n        if self.capacity >= new_capacity:\r\n            return\r\n        self._realloc(new_capacity)", "input": "Reserves the requested capacity.\r\n\r\n        If the current capacity is greater or equal, this is a no-op.\r\n        Otherwise, the storage is reallocated and the date is moved.\r\n\r\n        Args:\r\n            new_capacity: The new capacity.\r\n        "}, {"output": "    fn reverse(inout self):\r\n          self._reverse()", "input": "Reverses the elements of the list."}, {"output": "    fn clear(inout self):        for i in range(self.size):\n            _ = (self.data + i).take_value()\n        self.size = 0", "input": "Clears the elements in the list."}, {"output": "    fn steal_data(inout self) -> AnyPointer[T]:\r\n\r\n        var ptr = self.data\r\n        self.data = AnyPointer[T]()\r\n        self.size = 0\r\n        self.capacity = 0\r\n        return ptr", "input": "Take ownership of the underlying pointer from the list.\r\n\r\n        Returns:\r\n            The underlying data.\r\n        "}, {"output": "    fn __setitem__(inout self, i: Int, owned value: T):\r\n       \r\n        debug_assert(-self.size <= i < self.size, \"index must be within bounds\")\r\n\r\n        var normalized_idx = i\r\n        if i < 0:\r\n            normalized_idx += len(self)\r\n\r\n        _ = (self.data + normalized_idx).take_value()\r\n        (self.data + normalized_idx).emplace_value(value ^)", "input": "Sets a list element at the given index.\r\n\r\n        Args:\r\n            i: The index of the element.\r\n            value: The value to assign.\r\n        "}, {"output": "    @always_inline\r\n    fn _adjust_span(self, span: Slice) -> Slice:\r\n      \r\n        var adjusted_span = span\r\n\r\n        if adjusted_span.start < 0:\r\n            adjusted_span.start = len(self) + adjusted_span.start\r\n\r\n        if not adjusted_span._has_end():\r\n            adjusted_span.end = len(self)\r\n        elif adjusted_span.end < 0:\r\n            adjusted_span.end = len(self) + adjusted_span.end\r\n\r\n        if span.step < 0:\r\n            var tmp = adjusted_span.end\r\n            adjusted_span.end = adjusted_span.start - 1\r\n            adjusted_span.start = tmp - 1\r\n\r\n        return adjusted_span", "input": "Adjusts the span based on the list length."}, {"output": "    @always_inline\r\n    fn __getitem__(self, span: Slice) -> Self:\r\n        \r\n\r\n        var adjusted_span = self._adjust_span(span)\r\n        var adjusted_span_len = len(adjusted_span)\r\n\r\n        if not adjusted_span_len:\r\n            return Self()\r\n\r\n        var res = Self(capacity=len(adjusted_span))\r\n        for i in range(len(adjusted_span)):\r\n            res.append(self[adjusted_span[i]])\r\n\r\n        return res ^", "input": "Gets the sequence of elements at the specified positions.\r\n\r\n        Args:\r\n            span: A slice that specifies positions of the new list.\r\n\r\n        Returns:\r\n            A new list containing the list at the specified span.\r\n"}, {"output": "    fn __iter__[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _ListIter[\r\n        T, mutability, self_life\r\n    ]:\r\n       \r\n        return _ListIter[T, mutability, self_life](0, Reference(self))", "input": "Iterate over elements of the list, returning immutable references.\r\n\r\n        Returns:\r\n            An iterator of immutable references to the list elements.\r\n"}, {"output": "struct Set[T: KeyElement](Sized, EqualityComparable, Hashable, Boolable):\r\n    ", "input": "A set data type."}, {"output": "fn __init__(inout self, *ts: T):\r\n\r\n        self._data = Dict[T, NoneType]()\r\n        for t in ts:\r\n            self.add(t[])", "input": "Construct a set from initial elements.\r\n\r\n        Args:\r\n            ts: Variadic of elements to add to the set.\r\n"}, {"output": "    fn __init__(inout self, elements: Self):\r\n \r\n        self.__init__()\r\n        for e in elements:\r\n            self.add(e[])", "input": "Explicitly copy another Set instance.\r\n\r\n        Args:\r\n            elements: An existing set to copy.\r\n"}, {"output": "    fn __init__(inout self, elements: List[T]):\r\n\r\n        self.__init__()\r\n        for e in elements:\r\n            self.add(e[])\r\n", "input": "Construct a set from a List of elements.\n\n        Args:\n            elements: A vector of elements to add to the set.\n"}, {"output": "    fn __moveinit__(inout self, owned other: Self):\r\n\r\n        self._data = other._data ^", "input": "Move constructor.\r\n\r\n        Args:\r\n            other: The existing Set instance to move from.\r\n"}, {"output": "    fn __contains__(self, t: T) -> Bool:\r\n \r\n        return t in self._data", "input": "Whether or not the set contains an element.\r\n\r\n        Args:\r\n            t: The element to check membership in the set.\r\n\r\n        Returns:\r\n            Whether or not the set contains the element.\r\n "}, {"output": "    fn __bool__(self) -> Bool:\r\n\r\n        return len(self).__bool__()", "input": "Whether the set is non-empty or not.\r\n\r\n        Returns:\r\n            True if the set is non-empty, False if it is empty.\r\n       "}, {"output": "    fn __hash__(self) -> Int:\n\n        var hash_value = 0\n        # Hash combination needs to be commutative so iteration order\n        # doesn't impact the hash value.\n        for e in self:\n            hash_value ^= hash(e[])\n        return hash_value", "input": "A hash value of the elements in the set.\n\n        The hash value is order independent, so s1 == s2 -> hash(s1) == hash(s2).\n\n        Returns:\n            A hash value of the set suitable for non-cryptographic purposes.\r\n   "}, {"output": "    fn __and__(self, other: Self) -> Self:\n\n        return self.intersection(other)", "input": "The set intersection operator.\n\n        Args:\n            other: Another Set instance to intersect with this one.\n\n        Returns:\n            A new set containing only the elements which appear in both\n            this set and the `other` set.\r\n        "}, {"output": "    fn __or__(self, other: Self) -> Self:\r\n       \r\n        return self.union(other)", "input": "The set union operator.\r\n\r\n        Args:\r\n            other: Another Set instance to union with this one.\r\n\r\n        Returns:\r\n            A new set containing any elements which appear in either\r\n            this set or the `other` set.\r\n"}, {"output": "    fn __ior__(inout self, other: Self):\r\n\r\n        for e in other:\r\n            self.add(e[])", "input": "In-place set union.\r\n\r\n        Updates the set to contain all elements in the `other` set\r\n        as well as all elements it already contained.\r\n\r\n        Args:\r\n            other: Another Set instance to union with this one.\r\n "}, {"output": "    fn __sub__(self, other: Self) -> Self:\r\n\r\n        var result = Set[T]()\r\n        for e in self:\r\n            if e[] not in other:\r\n                result.add(e[])\r\n        return result ^\r\n", "input": "Set subtraction.\r\n\r\n        Args:\r\n            other: Another Set instance to subtract from this one.\r\n\r\n        Returns:\r\n            A new set containing elements of this set, but not containing\r\n            any elements which were in the `other` set.\r\n        "}, {"output": "    fn __isub__(inout self, other: Self):\n\n        self.remove_all(other)", "input": "In-place set subtraction.\r\n\r\n        Updates the set to remove any elements from the `other` set.\r\n\r\n        Args:\r\n            other: Another Set instance to subtract from this one.\r\n       "}, {"output": "    fn add(inout self, t: T):\n\n        self._data[t] = None", "input": "Add an element to the set.\r\n\r\n        Args:\r\n            t: The element to add to the set.\r\n        "}, {"output": "    fn remove(inout self, t: T) raises:\n        self._data.pop(t)", "input": "Remove an element from the set.\r\n\r\n        Args:\r\n            t: The element to remove from the set.\r\n\r\n        Raises:\r\n            If the element isn't in the set to remove.\r\n\r\n"}, {"output": "    fn pop(inout self) raises -> T:\n\n        if not self:\n            raise \"Pop on empty set\"\n        var iter = self.__iter__()\n        var first = iter.__next__()[]\n        self.remove(first)\n        return first", "input": "Remove any one item from the set, and return it.\r\n\r\n        As an implementation detail this will remove the first item\r\n        according to insertion order. This is practically useful\r\n        for breadth-first search implementations.\r\n\r\n        Returns:\r\n            The element which was removed from the set.\r\n\r\n        Raises:\r\n            If the set is empty.\r\n"}, {"output": "    fn union(self, other: Self) -> Self:\n\n        var result = Set(self)\n        for o in other:\n            result.add(o[])\n\n        return result ^", "input": "Set union.\r\n\r\n        Args:\r\n            other: Another Set instance to union with this one.\r\n\r\n        Returns:\r\n            A new set containing any elements which appear in either\r\n            this set or the `other` set.\r\n"}, {"output": "    fn intersection(self, other: Self) -> Self:\n\n        var result = Set[T]()\n        for v in self:\n            if v[] in other:\n                result.add(v[])\n\n        return result ^", "input": "Set intersection.\r\n\r\n        Args:\r\n            other: Another Set instance to intersect with this one.\r\n\r\n        Returns:\r\n            A new set containing only the elements which appear in both\r\n            this set and the `other` set.\r\n"}, {"output": "    fn remove_all(inout self, other: Self):\n\n        for o in other:\n            try:\n                self.remove(o[])\n            except:\n                pass", "input": "In-place set subtraction.\r\n\r\n        Updates the set to remove any elements from the `other` set.\r\n\r\n        Args:\r\n            other: Another Set instance to subtract from this one.\r\n"}, {"output": "    var conv_layer_one = Conv2D[\r\n        in_channels=1,\r\n        kernel_width=3,\r\n        kernel_height=3,\r\n        stride=1,\r\n        padding=0,\r\n        weight_initializer = HeUniform[1],\r\n        activation=\"relu\",\r\n    ]()", "input": "Create a 2D convolutional layer with kernel of 3, stride of 1, padding of 0 and relu activation function."}, {"output": "    var dense2 = Dense[\r\n        in_neurons=100,\r\n        out_neurons=10,\r\n        activation=\"sigmoid\",\r\n    ]()", "input": "Implement a dense layer with input size of 100 and output size of 10 and that uses the sigmoid activation function."}, {"output": "var true_vals = Tensor[TensorShape(batches, 10), Zeros]()", "input": "Create a variable to hold the values of a tensor structure. The tensor is defined with a shape specified by TensorShape(batches, 10) and is filled with zeros."}, {"output": " var input = Tensor[TensorShape(batches, channels, width, height), Zeros]()", "input": "The tensor is structured with a specific shape and filled with zeros."}, {"output": "var epoch_start = now()", "input": "Create a variable to store the start time of an epoch."}, {"output": "    for epoch in range(1, num_epochs + 1):\n        for i in range(batches):\n            var image = dataset.train_images[i + epoch * batches]\n            var label = dataset.train_labels[i + epoch * batches].to_int()\n            true_vals[i * 10 + label] = 1.0\n            for j in range(width):\n                for k in range(height):\n                    input[i * channels * width * height + j * width + k] = image[\n                        j * width + k\n                    ].to_int()", "input": "A for loop that iterates over the number if epochs, then another another for loop to iterate over the batches. A variable called image is declared and initialized with the training image data corresponding to the current index in the dataset for the current epoch. The true_vals are the true values of the train set. The two inner most loops iterate over each pixel of the image and convert it to an integer value."}, {"output": "    @always_inline\n    fn __init__(inout self, value: Scalar[type]):\n\n        self.value = value", "input": "Constructs a new atomic value.\r\n\r\n        Args:\r\n            value: Initial value represented as `Scalar[type]` type.\r\n        "}, {"output": "    @always_inline\r\n    fn __init__(inout self, value: Int):\r\n \r\n        self.__init__(Scalar[type](value))", "input": "Constructs a new atomic value.\r\n\r\n        Args:\r\n            value: Initial value represented as `mlir.index` type.\r\n        "}, {"output": "    @staticmethod\n    @always_inline\n    fn _fetch_add(\n        ptr: Pointer[Scalar[type]], rhs: Scalar[type]\n    ) -> Scalar[type]:\n\n        return __mlir_op.`pop.atomic.rmw`[\n            bin_op = __mlir_attr.`#pop<bin_op add>`,\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\n        ](\n            bitcast[__mlir_type[`!pop.scalar<`, type.value, `>`]](ptr).address,\n            rhs.value,\n        )", "input": "Performs atomic in-place add.\r\n\r\n        Atomically replaces the current value with the result of arithmetic\r\n        addition of the value and arg. That is, it performs atomic\r\n        post-increment. The operation is a read-modify-write operation. Memory\r\n        is affected according to the value of order which is sequentially\r\n        consistent.\r\n\r\n        Args:\r\n            ptr: The source pointer.\r\n            rhs: Value to add.\r\n\r\n        Returns:\r\n            The original value before addition.\r\n        "}, {"output": "    @always_inline\r\n    fn fetch_add(inout self, rhs: Scalar[type]) -> Scalar[type]:\r\n\r\n        var value_addr = Pointer.address_of(self.value)\r\n        return Self._fetch_add(value_addr, rhs)", "input": " Performs atomic in-place add.\r\n\r\n        Atomically replaces the current value with the result of arithmetic\r\n        addition of the value and arg. That is, it performs atomic\r\n        post-increment. The operation is a read-modify-write operation. Memory\r\n        is affected according to the value of order which is sequentially\r\n        consistent.\r\n\r\n        Args:\r\n            rhs: Value to add.\r\n\r\n        Returns:\r\n            The original value before addition.\r\n        "}, {"output": "    @always_inline\r\n    fn __iadd__(inout self, rhs: Scalar[type]):\r\n\r\n        _ = self.fetch_add(rhs)", "input": " Performs atomic in-place add.\r\n\r\n        Atomically replaces the current value with the result of arithmetic\r\n        addition of the value and arg. That is, it performs atomic\r\n        post-increment. The operation is a read-modify-write operation. Memory\r\n        is affected according to the value of order which is sequentially\r\n        consistent.\r\n\r\n        Args:\r\n            rhs: Value to add.\r\n        "}, {"output": "    @always_inline\r\n    fn fetch_sub(inout self, rhs: Scalar[type]) -> Scalar[type]:\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        return __mlir_op.`pop.atomic.rmw`[\r\n            bin_op = __mlir_attr.`#pop<bin_op sub>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\r\n        ](value_addr.address, rhs.value)", "input": "Performs atomic in-place sub.\n\n        Atomically replaces the current value with the result of arithmetic\n        subtraction of the value and arg. That is, it performs atomic\n        post-decrement. The operation is a read-modify-write operation. Memory\n        is affected according to the value of order which is sequentially\n        consistent.\n\n        Args:\n            rhs: Value to subtract.\n\n        Returns:\n            The original value before subtraction.\n"}, {"output": "    @always_inline\r\n    fn __isub__(inout self, rhs: Scalar[type]):\r\n\r\n        _ = self.fetch_sub(rhs)", "input": "Performs atomic in-place sub.\r\n\r\n        Atomically replaces the current value with the result of arithmetic\r\n        subtraction of the value and arg. That is, it performs atomic\r\n        post-decrement. The operation is a read-modify-write operation. Memory\r\n        is affected according to the value of order which is sequentially\r\n        consistent.\r\n\r\n        Args:\r\n            rhs: Value to subtract.\r\n        "}, {"output": "    @always_inline\r\n    fn max(inout self, rhs: Scalar[type]):\r\n\r\n        constrained[\r\n            type.is_integral() or type.is_floating_point(),\r\n            \"the input type must be arithmetic\",\r\n        ]()\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        _ = __mlir_op.`pop.atomic.rmw`[\r\n            bin_op = __mlir_attr.`#pop<bin_op max>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\r\n        ](value_addr.address, rhs.value)", "input": "Performs atomic in-place max.\r\n\r\n        Atomically replaces the current value with the result of max of the\r\n        value and arg. The operation is a read-modify-write operation perform\r\n        according to sequential consistency semantics.\r\n\r\n        Constraints:\r\n            The input type must be either integral or floating-point type.\r\n\r\n\r\n        Args:\r\n            rhs: Value to max.\r\n        "}, {"output": "    @always_inline\r\n    fn min(inout self, rhs: Scalar[type]):\r\n\r\n\r\n        constrained[\r\n            type.is_integral() or type.is_floating_point(),\r\n            \"the input type must be arithmetic\",\r\n        ]()\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        _ = __mlir_op.`pop.atomic.rmw`[\r\n            bin_op = __mlir_attr.`#pop<bin_op min>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\r\n        ](value_addr.address, rhs.value)", "input": "Performs atomic in-place min.\r\n\r\n        Atomically replaces the current value with the result of min of the\r\n        value and arg. The operation is a read-modify-write operation. The\r\n        operation is a read-modify-write operation perform according to\r\n        sequential consistency semantics.\r\n\r\n        Constraints:\r\n            The input type must be either integral or floating-point type.\r\n\r\n        Args:\r\n            rhs: Value to min.\r\n "}, {"output": "fn setenv(name: String, value: String, overwrite: Bool = True) -> Bool:\r\n\r\n    alias os_is_supported = os_is_linux() or os_is_macos()\r\n    if not os_is_supported:\r\n        return False\r\n\r\n    var status = external_call[\"setenv\", Int32](\r\n        name._as_ptr(), value._as_ptr(), Int32(1 if overwrite else 0)\r\n    )\r\n    return status == 0", "input": "Changes or adds an environment variable.\r\n\r\n    Constraints:\r\n      The function only works on macOS or Linux and returns False otherwise.\r\n\r\n    Args:\r\n      name: The name of the environment variable.\r\n      value: The value of the environment variable.\r\n      overwrite: If an environment variable with the given name already exists,\r\n        its value is not changed unless `overwrite` is True.\r\n\r\n    Returns:\r\n      False if the name is empty or contains an `=` character. In any other\r\n      case, True is returned.\r\n    "}, {"output": "fn getenv(name: String, default: String = \"\") -> String:\r\n\r\n    alias os_is_supported = os_is_linux() or os_is_macos()\r\n\r\n    if not os_is_supported:\r\n        return default\r\n\r\n    var ptr = external_call[\"getenv\", DTypePointer[DType.int8]](name._as_ptr())\r\n    if not ptr:\r\n        return default\r\n    return String(StringRef(ptr))", "input": "Returns the value of the given environment variable.\r\n\r\n    Constraints:\r\n      The function only works on macOS or Linux and returns an empty string\r\n      otherwise.\r\n\r\n    Args:\r\n      name: The name of the environment variable.\r\n      default: The default value to return if the environment variable\r\n        doesn't exist.\r\n\r\n    Returns:\r\n      The value of the environment variable.\r\n"}, {"output": "fn stat[pathlike: os.PathLike](path: pathlike) raises -> stat_result:\r\n\r\n    return stat(path.__fspath__())\r\n", "input": "Get the status of a file or a file descriptor.\r\n\r\n    Parameters:\r\n      pathlike: The a type conforming to the os.PathLike trait.\r\n\r\n    Args:\r\n      path: The path to the directory.\r\n\r\n    Returns:\r\n      Returns the stat_result on the path.\r\n    "}, {"output": "fn list(self) -> List[String]:\r\n\r\n\r\n        @parameter\r\n        if os_is_linux():\r\n            return self._list_linux()\r\n        else:\r\n            return self._list_macos()", "input": "Reads all the data from the handle.\r\n\r\n        Returns:\r\n          A string containing the output of running the command.\r\n       "}, {"output": "    fn __del__(owned self):\r\n      \r\n        _ = external_call[\"closedir\", Int32](self._handle)", "input": "Closes the handle opened via popen."}, {"output": "fn listdir(path: String = \"\") raises -> List[String]:\r\n\r\n\r\n    var dir = _DirHandle(path)\r\n    return dir.list()", "input": "Gets the list of entries contained in the path provided.\r\n\r\n    Args:\r\n      path: The path to the directory.\r\n\r\n    Returns:\r\n      Returns the list of entries in the path provided.\r\n    "}, {"output": "fn listdir[pathlike: os.PathLike](path: pathlike) raises -> List[String]:\r\n\r\n    return listdir(path.__fspath__())", "input": "Gets the list of entries contained in the path provided.\r\n\r\n    Parameters:\r\n      pathlike: The a type conforming to the os.PathLike trait.\r\n\r\n    Args:\r\n      path: The path to the directory.\r\n\r\n\r\n    Returns:\r\n      Returns the list of entries in the path provided.\r\n    "}, {"output": "@always_inline(\"nodebug\")\r\nfn abort[result: Movable = NoneType]() -> result:\r\n\r\n\r\n    __mlir_op.`llvm.intr.trap`()\r\n\r\n    return AnyPointer[result]().take_value()", "input": "Calls a target dependent trap instruction if available.\r\n\r\n    Parameters:\r\n        result: The result type.\r\n\r\n    Returns:\r\n        A null result type.\r\n    "}, {"output": "@always_inline(\"nodebug\")\r\nfn abort[\r\n    result: Movable = NoneType, *, stringable: Stringable\r\n](message: stringable) -> result:\r\n \r\n\r\n    @parameter\r\n    if not triple_is_nvidia_cuda():\r\n        print(message, flush=True)\r\n\r\n    return abort[result]()", "input": "Calls a target dependent trap instruction if available.\r\n\r\n    Parameters:\r\n        result: The result type.\r\n        stringable: The Stringable type.\r\n\r\n    Args:\r\n        message: The message to include when aborting.\r\n\r\n    Returns:\r\n        A null result type."}, {"output": "    fn __init__(inout self, path: String) raises:\r\n\r\n        constrained[\r\n            not os_is_windows(), \"operation is only available on unix systems\"\r\n        ]()\r\n\r\n        if not isdir(path):\r\n            raise \"the directory '\" + path + \"' does not exist\"\r\n\r\n        self._handle = external_call[\"opendir\", Pointer[NoneType]](\r\n            path._as_ptr()\r\n        )\r\n\r\n        if not self._handle:\r\n            raise \"unable to open the directory '\" + path + \"'\"", "input": "Construct the _DirHandle using the path provided.\r\n\r\n        Args:\r\n          path: The path to open.\r\n        "}, {"output": "@always_inline\r\nfn _clock_gettime(clockid: Int) -> _CTimeSpec:\r\n  \r\n    var ts = _CTimeSpec()\r\n\r\n    # Call libc's clock_gettime.\r\n    _ = external_call[\"clock_gettime\", Int32](\r\n        Int32(clockid), Pointer.address_of(ts)\r\n    )\r\n\r\n    return ts", "input": "Low-level call to the clock_gettime libc function"}, {"output": "@always_inline\r\nfn _realtime_nanoseconds() -> Int:\r\n   \r\n    return _gettime_as_nsec_unix(_CLOCK_REALTIME)", "input": "Returns the current realtime time in nanoseconds"}, {"output": "@always_inline\r\nfn _monotonic_nanoseconds() -> Int:\r\n    \r\n\r\n    @parameter\r\n    if os_is_windows():\r\n        var ft = _FILETIME()\r\n        external_call[\"GetSystemTimePreciseAsFileTime\", NoneType](\r\n            Pointer.address_of(ft)\r\n        )\r\n\r\n        return ft.as_nanoseconds()\r\n    else:\r\n        return _gettime_as_nsec_unix(_CLOCK_MONOTONIC)", "input": "Returns the current monotonic time in nanoseconds"}, {"output": "@always_inline\r\nfn _monotonic_raw_nanoseconds() -> Int:\r\n  \r\n\r\n    return _gettime_as_nsec_unix(_CLOCK_MONOTONIC_RAW)", "input": "Returns the current monotonic time in nanoseconds"}, {"output": "@always_inline\r\nfn _process_cputime_nanoseconds() -> Int:\r\n   \r\n\r\n    return _gettime_as_nsec_unix(_CLOCK_PROCESS_CPUTIME_ID)", "input": "Returns the high-resolution per-process timer from the CPU"}, {"output": "@always_inline\nfn now() -> Int:\n\n    return _monotonic_nanoseconds()", "input": "Returns the current monotonic time time in nanoseconds. This function\n    queries the current platform's monotonic clock, making it useful for\n    measuring time differences, but the significance of the returned value\n    varies depending on the underlying implementation.\n\n    Returns:\n        The current time in ns.\r\n   "}, {"output": "@always_inline\n@parameter\nfn time_function[func: fn () capturing -> None]() -> Int:\n\n\n    @parameter\n    if os_is_windows():\n        return _time_function_windows[func]()\n\n    var tic = now()\n    func()\n    var toc = now()\n    return toc - tic", "input": "Measures the time spent in the function.\r\n\r\n    Parameters:\r\n        func: The function to time.\r\n\r\n    Returns:\r\n        The time elapsed in the function in ns.\r\n    "}, {"output": "fn sleep(sec: Int):\r\n\r\n\r\n    @parameter\r\n    if os_is_windows():\r\n        # In Windows the argument is in milliseconds.\r\n        external_call[\"Sleep\", NoneType](sec * 1000)\r\n    else:\r\n        external_call[\"sleep\", NoneType](sec)", "input": "Suspends the current thread for the seconds specified.\r\n\r\n    Args:\r\n        sec: The number of seconds to sleep for.\r\n    "}, {"output": "    @always_inline(\"nodebug\")\r\n    fn __lt__(self, rhs: Self) -> Bool:\r\n\r\n        return int(self) < int(rhs)", "input": "Returns True if this pointer represents a lower address than rhs.\r\n\r\n        Args:\r\n            rhs: The value of the other pointer.\r\n\r\n        Returns:\r\n            True if this pointer represents a lower address and False otherwise.\r\n        "}]