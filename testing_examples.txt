"@always_inline\n    fn each_idx[\n        func: fn[idx: Int, T: element_trait] (T) capturing -> None\n    ](self): @parameter\n        fn unrolled[i: Int]():\n            func[i, element_types[i.value]](self.get_element[i]()[])\n\n        unroll[unrolled, Self.__len__()]()"
"    @always_inline\r\n    fn normalize(self) -> Vec3f:\r\n        return self.data * rsqrt(self @ self))"
"struct MyPet:\r\n    var name: String\r\n    var age: Int\r\n\r\n    fn __init__(inout self, owned name: String, age: Int):\r\n        self.name = name^\r\n        self.age = age"
"@always_inline\r\nfn _max(a: Int, b: Int) -> Int:\r\n    return a if a > b else b"
"fn mandelbrot_kernel_SIMD[\r\n    simd_width: Int\r\n](c: ComplexSIMD[float_type, simd_width]) -> SIMD[int_type, simd_width]:\r\n    \"\"\"A vectorized implementation of the inner mandelbrot computation.\"\"\"\r\n    var cx = c.re\r\n    var cy = c.im\r\n    var x = SIMD[float_type, simd_width](0)\r\n    var y = SIMD[float_type, simd_width](0)\r\n    var y2 = SIMD[float_type, simd_width](0)\r\n    var iters = SIMD[int_type, simd_width](0)\r\n\r\n    var t: SIMD[DType.bool, simd_width] = True\r\n    for i in range(MAX_ITERS):\r\n        if not t.reduce_or():\r\n            break\r\n        y2 = y * y\r\n        y = x.fma(y + y, cy)\r\n        t = x.fma(x, y2) <= 4\r\n        x = x.fma(x, cx - y2)\r\n        iters = t.select(iters + 1, iters)\r\n    return iters"
"from math import tan, acos\r\nfrom algorithm import parallelize\r\n\r\n\r\nfn create_image_with_sphere(sphere: Sphere, height: Int, width: Int) -> Image:\r\n    var image = Image(height, width)\r\n\r\n    @parameter\r\n    fn _process_row(row: Int):\r\n        var y = -((2.0 * row + 1) / height - 1)\r\n        for col in range(width):\r\n            var x = ((2.0 * col + 1) / width - 1) * width / height\r\n            var dir = Vec3f(x, y, -1).normalize()\r\n            image.set(row, col, cast_ray(Vec3f.zero(), dir, sphere))\r\n\r\n    parallelize[_process_row](height)\r\n\r\n    return image"