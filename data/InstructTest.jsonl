{
    "text": "<s>[INST] Asserts that the input value is True. If it is not then an   Error is raised.   Parameters:       T: A Boolable type.   Args:       val: The value to assert to be True.       msg: The message to be printed if the assertion fails.   Raises:       An Error with the provided message if assert fails and `None` otherwise. [/INST]@always_inlinefn assert_true[   T: Boolable](val: T msg: String = \"condition was unexpectedly False\") raises:   if not val:       raise Error(\"AssertionError: \" + msg)</s>"
}
{
    "text": "<s>[INST] Asserts that the input value is False. If it is not then an Error is   raised.   Parameters:       T: A Boolable type.   Args:       val: The value to assert to be False.       msg: The message to be printed if the assertion fails.   Raises:       An Error with the provided message if assert fails and `None` otherwise.  [/INST]@always_inlinefn assert_false[   T: Boolable](val: T msg: String = \"condition was unexpectedly True\") raises:   if val:       raise Error(\"AssertionError: \" + msg)</s>"
}
{
    "text": "<s>[INST] Asserts that the input values are equal. If it is not then an Error   is raised.   Args:       lhs: The lhs of the equality.       rhs: The rhs of the equality.       msg: The message to be printed if the assertion fails.   Raises:       An Error with the provided message if assert fails and `None` otherwise.   [/INST]@always_inlinefn assert_equal(lhs: Int rhs: Int msg: String = \"\") raises:   if lhs != rhs:       raise _assert_equal_error(str(lhs) str(rhs) msg=msg)</s>"
}
{
    "text": "<s>[INST]  Asserts that the input values are equal. If it is not then an Error   is raised.   Args:       lhs: The lhs of the equality.       rhs: The rhs of the equality.       msg: The message to be printed if the assertion fails.   Raises:       An Error with the provided message if assert fails and `None` otherwise.   [/INST]@always_inlinefn assert_equal(lhs: String rhs: String msg: String = \"\") raises:   if lhs != rhs:       raise _assert_equal_error(lhs rhs msg=msg)</s>"
}
{
    "text": "<s>[INST] Asserts that the input values are equal. If it is not then an   Error is raised.   Parameters:       type: The dtype of the left- and right-hand-side SIMD vectors.       size: The width of the left- and right-hand-side SIMD vectors.   Args:       lhs: The lhs of the equality.       rhs: The rhs of the equality.       msg: The message to be printed if the assertion fails.   Raises:       An Error with the provided message if assert fails and `None` otherwise.[/INST]@always_inlinefn assert_equal[   type: DType size: Int](lhs: SIMD[type size] rhs: SIMD[type size] msg: String = \"\") raises:   if lhs != rhs:       raise _assert_equal_error(str(lhs) str(rhs) msg=msg)</s>"
}
{
    "text": "<s>[INST] Asserts that the input values are not equal. If it is not then an   Error is raised.   Args:       lhs: The lhs of the inequality.       rhs: The rhs of the inequality.       msg: The message to be printed if the assertion fails.   Raises:       An Error with the provided message if assert fails and `None` otherwise.   [/INST]@always_inlinefn assert_not_equal(lhs: Int rhs: Int msg: String = \"\") raises:   if lhs == rhs:       raise _assert_not_equal_error(str(lhs) str(rhs) msg=msg)</s>"
}
{
    "text": "<s>[INST] Asserts that the input values are not equal. If it is not then an   an Error is raised.   Args:       lhs: The lhs of the inequality.       rhs: The rhs of the inequality.       msg: The message to be printed if the assertion fails.   Raises:       An Error with the provided message if assert fails and `None` otherwise.   [/INST]@always_inlinefn assert_not_equal(lhs: String rhs: String msg: String = \"\") raises:   if lhs == rhs:       raise _assert_not_equal_error(str(lhs) str(rhs) msg=msg)</s>"
}
{
    "text": "<s>[INST] Asserts that the input values are not equal. If it is not then an   Error is raised.   Parameters:       type: The dtype of the left- and right-hand-side SIMD vectors.       size: The width of the left- and right-hand-side SIMD vectors.   Args:       lhs: The lhs of the inequality.       rhs: The rhs of the inequality.       msg: The message to be printed if the assertion fails.   Raises:       An Error with the provided message if assert fails and `None` otherwise.   [/INST]@always_inlinefn assert_not_equal[   type: DType size: Int](lhs: SIMD[type size] rhs: SIMD[type size] msg: String = \"\") raises:   if lhs == rhs:       raise _assert_not_equal_error(str(lhs) str(rhs) msg=msg)</s>"
}
{
    "text": "<s>[INST] Asserts that the input values are equal up to a tolerance. If it is   not then an Error is raised.   Parameters:       type: The dtype of the left- and right-hand-side SIMD vectors.       size: The width of the left- and right-hand-side SIMD vectors.   Args:       lhs: The lhs of the equality.       rhs: The rhs of the equality.       msg: The message to print.       atol: The _absolute tolerance.       rtol: The relative tolerance.   Raises:       An Error with the provided message if assert fails and `None` otherwise.   [/INST]@always_inline\nfn assert_almost_equal[\n    type: DType size: Int\n](\n    lhs: SIMD[type size]\n    rhs: SIMD[type size]\n    /\n    *\n    msg: String = \"\"\n    atol: Scalar[type] = 1e-08\n    rtol: Scalar[type] = 1e-05\n) raises:\n\n    var almost_equal = _isclose(lhs rhs atol=atol rtol=rtol)\n    if not almost_equal:\n        var err = \"AssertionError: \" + str(lhs) + \" is not close to \" + str(\n            rhs\n        ) + \" with a diff of \" + _abs(lhs - rhs)\n        if msg:\n            err += \" (\" + msg + \")\"\n        raise err\n</s>"
}
{
    "text": "<s>[INST] Construct a context manager matching specific errors.       Args:           contains: The test will only pass if the error message               includes the literal text passed.       [/INST]    fn __init__(inout self * contains: String):\n\n        self.message_contains = contains</s>"
}
{
    "text": "<s>[INST] Exit the context manager with no error.       Raises:           AssertionError: Always. The block must raise to pass the test.       [/INST]    fn __exit__(self) raises:       raise Error(\"AssertionError: Didn't raise\")</s>"
}
{
    "text": "<s>[INST] Return true if the named value is defined.   Parameters:       name: The name to test.   Returns:       True if the name is defined.   [/INST]fn is_defined[name: StringLiteral]() -> Bool:   alias result = __mlir_attr[       `#kgen.param.expr<get_env ` name.value `> : i1`   ]   return result</s>"
}
{
    "text": "<s>[INST] Try to get an integer-valued define. If the name is not defined return   a default value instead.   Parameters:       name: The name of the define.       default: The default value to use.   Returns:       An integer parameter value.   [/INST]fn env_get_int[name: StringLiteral default: Int]() -> Int:\n\n\n    @parameter\n    if is_defined[name]():\n        return env_get_int[name]()\n    else:\n        return default</s>"
}
{
    "text": "<s>[INST] Applies a given element binary function to each pair of corresponding   elements in two tuples.   Example Usage:       var a: StaticTuple[Int size]       var b: StaticTuple[Int size]       var c = _int_tuple_binary_apply[size Int.add](a b)   Parameters:       size: Static size of the operand and result tuples.       binary_fn: Binary function to apply to tuple elements.   Args:       a: Tuple containing lhs operands of the elementwise binary function.       b: Tuple containing rhs operands of the elementwise binary function.   Returns:       Tuple containing the result.[/INST]@always_inlinefn _int_tuple_binary_apply[   size: Int   binary_fn: fn (Int Int) -> Int](a: StaticTuple[Int size] b: StaticTuple[Int size]) -> StaticTuple[   Int size]:   var c = StaticTuple[Int size]()   @always_inline   @parameter   fn do_apply[idx: Int]():       var a_elem: Int = a.__getitem__[idx]()       var b_elem: Int = b.__getitem__[idx]()       c.__setitem__[idx](binary_fn(a_elem b_elem))   unroll[do_apply size]()   return c</s>"
}
{
    "text": "<s>[INST] Reduces the tuple argument with the given reduce function and initial   value.   Example Usage:       var a: StaticTuple[mlir_bool size]       var c = _bool_tuple_reduce[size _reduce_and_fn](a True)   Parameters:       size: Static size of the operand and result tuples.       reduce_fn: Reduce function to accumulate tuple elements.   Args:       a: Tuple containing elements to reduce.       init: Value to initialize the reduction with.   Returns:       The result of the reduction.   [/INST]@always_inlinefn _bool_tuple_reduce[   size: Int   reduce_fn: fn (Bool Bool) -> Bool](a: StaticTuple[mlir_bool size] init: Bool) -> Bool:   var c: Bool = init   @always_inline   @parameter   fn do_reduce[idx: Int]():       c = reduce_fn(c a.__getitem__[idx]())   unroll[do_reduce size]()   return c</s>"
}
{
    "text": "<s>[INST] A base struct that implements size agnostic index functions.   Parameters:       size: The size of the tuple.   [/INST]@value\n@register_passable(\"trivial\")\nstruct StaticIntTuple[size: Int](Sized Stringable EqualityComparable):\n\n\n    var data: StaticTuple[Int size]\n    \"\"\"The underlying storage of the tuple value.\"\"\"\n\n    @always_inline\n    fn __init__() -> Self:\n        \"\"\"Constructs a static int tuple of the given size.\n\n        Returns:\n            The constructed tuple.\n        \"\"\"\n        return 0</s>"
}
{
    "text": "<s>[INST] Constructs a sized 1 static int tuple of given the element value.       Args:           value: The initial value.       Returns:           The constructed tuple.       [/INST]    @always_inline   fn __init__(value: __mlir_type.index) -> Self:       constrained[size == 1]()       return Int(value)</s>"
}
{
    "text": "<s>[INST] Constructs a static int tuple given a tuple of integers.       Args:           elems: The tuple to copy from.       Returns:           The constructed tuple.       [/INST]    @always_inline   fn __init__(elems: Tuple[Int Int]) -> Self:       var num_elements = len(elems)       debug_assert(           size == num_elements           \"[StaticIntTuple] mismatch in the number of elements\"       )       var tup = Self()       @parameter       fn fill[idx: Int]():           tup[idx] = elems.get[idx Int]()       unroll[fill 2]()       return tup</s>"
}
{
    "text": "<s>[INST] Constructs a static int tuple given a set of arguments.       Args:           elems: The elements to construct the tuple.       Returns:           The constructed tuple.       \n[/INST]    @always_inline   fn __init__(*elems: Int) -> Self:       var num_elements = len(elems)       debug_assert(           size == num_elements           \"[StaticIntTuple] mismatch in the number of elements\"       )       var tup = Self()       @unroll       for idx in range(size):           tup[idx] = elems[idx]       return tup</s>"
}
{
    "text": "<s>[INST] Creates a tuple constant using the specified values.       Args:           values: The list of values.       Returns:           A tuple with the values filled in.[/INST]    @always_inline   fn __init__(values: VariadicList[Int]) -> Self:       constrained[size > 0]()       return Self {data: values}   @always_inline(\"nodebug\")   fn __len__(self) -> Int:       \"\"\"Returns the size of the tuple.       Returns:           The tuple size.       \"\"\"       return size</s>"
}
{
    "text": "<s>[INST] Bitcasts the floating-point value to an integer.   Parameters:       type: The floating-point type.   Args:       value: The value to bitcast.   Returns:       An integer representation of the floating-point value.   [/INST]@always_inlinefn _fp_bitcast_to_integer[type: DType](value: Scalar[type]) -> Int:   alias integer_type = _integral_type_of[type]()   return int(bitcast[integer_type 1](value))</s>"
}
{
    "text": "<s>[INST]  Returns the exponent and mantissa mask of a floating point type. It is       computed by `exponent_mask + mantissa_mask`.       Returns:           The exponent and mantissa mask.[/INST]    @staticmethod   @always_inline   fn exponent_mantissa_mask() -> Int:       constrained[           type.is_floating_point()           \"dtype must be a floating point type\"       ]()       return Self.exponent_mask() + Self.mantissa_mask()</s>"
}
{
    "text": "<s>[INST] Bitcasts the floating-point value to an integer.       Args:           value: The floating-point type.       Returns:           An integer representation of the floating-point value.       [/INST]    @staticmethod   @always_inline   fn bitcast_to_integer(value: Scalar[type]) -> Int:       return _fp_bitcast_to_integer[type](value)</s>"
}
{
    "text": "<s>[INST] Bitcasts the floating-point value from an integer.       Args:           value: The int value.       Returns:           An floating-point representation of the Int.[/INST]    @staticmethod   @always_inline   fn bitcast_from_integer(value: Int) -> Scalar[type]:       return _fp_bitcast_from_integer[type](value)</s>"
}
{
    "text": "<s>[INST] Returns the sign of the floating point value. True if the sign is set       and False otherwise.       Args:           value: The floating-point type.       Returns:           Returns True if the sign is set and False otherwise.       [/INST]    @staticmethod   @always_inline   fn get_sign(value: Scalar[type]) -> Bool:       return (Self.bitcast_to_integer(value) & Self.sign_mask()) != 0</s>"
}
{
    "text": "<s>[INST] Returns the exponent bits of the floating-point value.       Args:           value: The floating-point value.       Returns:           Returns the exponent bits.       [/INST]    @staticmethod   @always_inline   fn get_exponent(value: Scalar[type]) -> Int:       return (           Self.bitcast_to_integer(value) & Self.exponent_mask()       ) >> Self.mantissa_width()</s>"
}
{
    "text": "<s>[INST] Create a pointer with the input value.       Args:           value: The input pointer to construct with.       Returns:           A null pointer.       [/INST]@always_inline   fn __init__(value: Self.pointer_type) -> Self:            return Self {value: value}</s>"
}
{
    "text": "<s>[INST] Allocate an array with default alignment.       Args:           count: The number of elements in the array.       Returns:           The pointer to the newly allocated array.   [/INST]    @staticmethod   @always_inline   fn alloc(count: Int) -> Self:       return Self.__from_index(           int(_malloc[Int8](sizeof[T]() * count alignment=alignof[T]()))       )</s>"
}
{
    "text": "<s>[INST] Gets the address of the argument.\n\n        Args:\n            arg: The value to get the address of.\n\n        Returns:\n            An AnyPointer which contains the address of the argument.\n        [/INST]    @staticmethod   @always_inline(\"nodebug\")   fn address_of(inout arg: T) -> Self:       return __mlir_op.`pop.pointer.bitcast`[_type = Self.pointer_type](           __get_lvalue_as_address(arg)       )</s>"
}
{
    "text": "<s>[INST] Free the memory referenced by the pointer.[/INST]    @always_inline   fn free(self):              Pointer[Int8].__from_index(int(self)).free()</s>"
}
{
    "text": "<s>[INST] Move the value at the pointer out.       The pointer must not be null and the pointer memory location is assumed       to contain a valid initialized instance of `T`.       This performs a _consuming_ move ending the lifetime of the value stored       in this pointer memory location. Subsequent reads of this pointer are       not valid. If a new valid value is stored using `emplace_value()` then       reading from this pointer becomes valid again.       Returns:           The value at the pointer.       [/INST]    @always_inline   fn take_value(self) -> T:       return __get_address_as_owned_value(self.value)</s>"
}
{
    "text": "<s>[INST] Emplace a new value into the pointer location.       The pointer memory location is assumed to contain uninitialized data       and consequently the current contents of this pointer are not destructed       before writing `value`. Similarly ownership of `value` is logically       transfered into the pointer location.       Args:           value: The value to emplace.   [/INST]    @always_inline\n    fn emplace_value(self owned value: T):\n\n        __get_address_as_uninit_lvalue(self.value) = value ^</s>"
}
{
    "text": "<s>[INST] Moves the value contained in this pointer into the memory location       pointed to by `dest`.       This performs a consuming move (using `__moveinit__()`) out of the       memory location pointed to by this pointer. Subsequent reads of this       pointer are not valid unless and until a new valid value has been       moved into this pointer's memory location using `emplace_value()`.       This transfers the value out of `self` and into `dest` using at most one       `__moveinit__()` call.       Safety:           * `self` must not be null           * `self` must contain a valid initialized instance of `T`           * `dest` must not be null           * The contents of `dest` should be uninitialized. If `dest` was             previously written with a valid value that value will be be             overwritten and its destructor will NOT be run.       Args:           dest: Destination pointer that the value will be moved into.       [/INST]    @always_inline\n    fn move_into(self dest: AnyPointer[T]):\n\n        __get_address_as_uninit_lvalue(\n            dest.value\n        ) = __get_address_as_owned_value(self.value)\n</s>"
}
{
    "text": "<s>[INST] Returns the pointer address as an integer.       Returns:         The address of the pointer as an Int.       [/INST]    @always_inline   fn __int__(self) -> Int:       return __mlir_op.`pop.pointer_to_index`[           _type = __mlir_type.`!pop.scalar<index>`       ](self.value)</s>"
}
{
    "text": "<s>[INST] Return true if the pointer is non-null.       Returns:           Whether the pointer is null.       [/INST]    @always_inline   fn __bool__(self) -> Bool:       return int(self) != 0</s>"
}
{
    "text": "<s>[INST] Return a pointer at an offset from the current one.       Args:           offset: The offset index.       Returns:           An offset pointer.       [/INST]    @always_inline   fn __add__(self offset: Int) -> Self:       return Self.__from_index(int(self) + offset * sizeof[T]())</s>"
}
{
    "text": "<s>[INST] Return a pointer at an offset from the current one.       Args:           offset: The offset index.       Returns:           An offset pointer.       [/INST]    @always_inline   fn __sub__(self offset: Int) -> Self:       return self + (-offset)</s>"
}
{
    "text": "<s>[INST] Returns True if the two pointers are equal.       Args:           rhs: The value of the other pointer.       Returns:           True if the two pointers are equal and False otherwise.       [/INST]    @always_inline(\"nodebug\")   fn __eq__(self rhs: Self) -> Bool:       return int(self) == int(rhs)</s>"
}
{
    "text": "<s>[INST] Returns True if the two pointers are not equal.       Args:           rhs: The value of the other pointer.       Returns:           True if the two pointers are not equal and False otherwise.       [/INST]    @always_inline(\"nodebug\")   fn __ne__(self rhs: Self) -> Bool:       return not (self == rhs)</s>"
}
