[
    {
        "text": "fn sigmoid(x: Float64) -> Float64:\r\n    return 1 / (1 + exp(-x))"
    },
    {
        "text": "fn gradient_descent(start: Float64, learning_rate: Float64, n_iter: Int=50, tolerance: Float64=1e-06) raises:\r\n    let np = Python.import_module('numpy')\r\n    var vector = start\r\n    for _ in range(n_iter):\r\n        let diff = -learning_rate * 2 * vector\r\n        if np.all(np.abs(diff) <= tolerance):\r\n            break\r\n        vector += diff\r\n    print(vector)"
    },
    {
        "text": "fn main():\r\n    print(\"Hello, world!\")"
    },
    {
        "text": "fn euclidean_dist(x1: Int64, y1: Int64, x2: Int64, y2: Int64):\r\n    let x = x2 - x1\r\n    let y = y2 - y1\r\n    let euclidean_distance = sqrt(pow(x, 2) + pow(y,2))\r\n    print(euclidean_distance)"
    },
    {
        "text": "def mandelbrot_kernel(c: ComplexFloat64) -> Int:\r\n    z = c\r\n    for i in range(MAX_ITERS):\r\n        z = z * z + c\r\n        if z.squared_norm() > 4:\r\n            return i\r\n    return MAX_ITERS"
    },
    {
        "text": "def compute_mandelbrot() -> Tensor[float_type]:\n    # create a matrix. Each element of the matrix corresponds to a pixel\n    t = Tensor[float_type](height, width)\n\n    dx = (max_x - min_x) / width\n    dy = (max_y - min_y) / height\n\n    y = min_y\n    for row in range(height):\n        x = min_x\n        for col in range(width):\n            t[Index(row, col)] = mandelbrot_kernel(ComplexFloat64(x, y))\n            x += dx\n        y += dy\n    return t"
    },
    {
        "text": "    fn is_https(self) -> Bool:\r\n        return bytes_equal(self.__scheme, strHttps)"
    },
    {
        "text": "    fn path_original(self) -> Bytes:\r\n        return self.__path_original"
    },
    {
        "text": "    fn set_path(inout self, path: String) -> Self:\r\n        self.__path = normalise_path(path._buffer, self.__path_original)"
    },
    {
        "text": "    fn set_path_sbytes(inout self, path: Bytes) -> Self:\r\n        self.__path = normalise_path(path, self.__path_original)\r\n        return self"
    },
    {
        "text": "    fn path(self) -> String:\n        var processed_path = self.__path\n        if len(processed_path) == 0:\n            processed_path = strSlash\n        return String(processed_path)\n"
    },
    {
        "text": "    fn set_scheme(inout self, scheme: String) -> Self:\r\n        self.__scheme = scheme._buffer\r\n        return self\r\n\r"
    },
    {
        "text": "    fn set_scheme_bytes(inout self, scheme: Bytes) -> Self:\r\n        self.__scheme = scheme\r\n        return self"
    },
    {
        "text": "    fn scheme(self) -> Bytes:\r\n        var processed_scheme = self.__scheme\r\n        if len(processed_scheme) == 0:\r\n            processed_scheme = strHttp\r\n        return processed_scheme\r"
    },
    {
        "text": "    fn is_https(self) -> Bool:\r\n        return bytes_equal(self.__scheme, strHttps)"
    },
    {
        "text": "    fn is_http(self) -> Bool:\r\n        return bytes_equal(self.__scheme, strHttp) or len(self.__scheme) == 0"
    },
    {
        "text": "@value\r\nstruct ErrorHandler:\r\n    fn Error(self) -> HTTPResponse:\r\n        return HTTPResponse(ResponseHeader(), String(\"TODO\").as_bytes())\r\n\r\n\r\nalias errNeedMore = Error(\"need more data: cannot find trailing lf\")\r\nalias errInvalidName = Error(\"invalid header name\")\r\nalias errSmallBuffer = Error(\"small read buffer. Increase ReadBufferSize\")"
    },
    {
        "text": "@value\nstruct HTTPResponse(Response):\n    var header: ResponseHeader\n    var stream_immediate_header_flush: Bool\n    var stream_body: Bool\n    var body_raw: Bytes\n    var skip_reading_writing_body: Bool\n    var raddr: TCPAddr\n    var laddr: TCPAddr\n\n    fn __init__(inout self, header: ResponseHeader, body_bytes: Bytes):\n        self.header = header\n        self.stream_immediate_header_flush = False\n        self.stream_body = False\n        self.body_raw = body_bytes\n        self.skip_reading_writing_body = False\n        self.raddr = TCPAddr()\n        self.laddr = TCPAddr()"
    },
    {
        "text": "    fn set_status_code(inout self, status_code: Int) -> Self:\r\n        _ = self.header.set_status_code(status_code)\r\n        return self"
    },
    {
        "text": "    fn status_code(self) -> Int:\r\n        return self.header.status_code()"
    },
    {
        "text": "    fn connection_close(self) -> Bool:\r\n        return self.header.connection_close()"
    },
    {
        "text": "fn OK(body: Bytes) -> HTTPResponse:\r\n    return HTTPResponse(\r\n        ResponseHeader(\r\n            True, 200, String(\"OK\").as_bytes(), String(\"Content-Type: text/plain\").as_bytes()\r\n        ),\r\n        body,\r\n    )"
    },
    {
        "text": "fn OK(body: Bytes, content_type: String) -> HTTPResponse:\r\n    return HTTPResponse(\r\n        ResponseHeader(True, 200, String(\"OK\").as_bytes(), content_type.as_bytes()), body\r\n    )"
    },
    {
        "text": "@value\nstruct TCPAddr(Addr):\n    var ip: String\n    var port: Int\n    var zone: String  # IPv6 addressing zone\n\n    fn __init__(inout self):\n        self.ip = String(\"127.0.0.1\")\n        self.port = 8000\n        self.zone = \"\"\n\n    fn __init__(inout self, ip: String, port: Int):\n        self.ip = ip\n        self.port = port\n        self.zone = \"\"\n\n    fn network(self) -> String:\n        return NetworkType.tcp.value\n\n    fn string(self) -> String:\n        if self.zone != \"\":\n            return join_host_port(String(self.ip) + \"%\" + self.zone, self.port)\n        return join_host_port(self.ip, self.port)\n"
    },
    {
        "text": "fn join_host_port(host: String, port: String) -> String:\n    if host.find(\":\") != -1:  # must be IPv6 literal\n        return \"[\" + host + \"]:\" + port\n    return host + \":\" + port"
    },
    {
        "text": "    fn write(self, data: String) raises -> Int:\r\n        var buffer: Str\r\n        with Str(data) as buffer:\r\n            var write_count: c_ssize_t = external_call[\r\n                \"write\", c_ssize_t, c_int, char_pointer, c_size_t\r\n            ](self.fd, buffer.vector.data, data.__len__())\r\n\r\n            if write_count == -1:\r\n                raise Error(\"Failed to write to file descriptor \" + self.fd.__str__())\r\n\r\n            return write_count"
    },
    {
        "text": "@value\r\nstruct Printer(HTTPService):\r\n    fn func(self, req: HTTPRequest) raises -> HTTPResponse:\r\n        var body = req.body_raw\r\n        print(String(body))\r\n\r\n        return OK(body)"
    },
    {
        "text": "@value\r\nstruct Welcome(HTTPService):\r\n    fn func(self, req: HTTPRequest) raises -> HTTPResponse:\r\n        var html: String\r\n        with open(\"static/lightbug_welcome.html\", \"r\") as f:\r\n            html = f.read()\r\n\r\n        return OK(html.as_bytes(), \"text/html\")"
    },
    {
        "text": "@value\nstruct ExampleRouter(HTTPService):\n    fn func(self, req: HTTPRequest) raises -> HTTPResponse:\n        var body = req.body_raw\n        var uri = req.uri()\n\n        if uri.path() == \"/\":\n            print(\"I'm on the index path!\")\n        if uri.path() == \"/first\":\n            print(\"I'm on /first!\")\n        elif uri.path() == \"/second\":\n            print(\"I'm on /second!\")\n        elif uri.path() == \"/echo\":\n            print(String(body))\n\n        return OK(body)"
    },
    {
        "text": "    @always_inline\n    fn __init__() -> Self:\n        # allocate a DTypePointer on stack that doesn't need to be freed.\n        var data = stack_allocation[width, T]()\n        memset_zero(data, width)\n        return Self {data: data}"
    },
    {
        "text": "    @always_inline\n    fn accumulate[_width: Int](inout self, val: SIMD[T, _width]) -> None:\n \n        var newVal = self.data.simd_load[_width]() + val\n        self.data.simd_store[_width](newVal)"
    },
    {
        "text": "struct TensorSlice:\r\n    var _data: BufferPtrFloat32\r\n    var _shape: TensorShape\r\n\r\n    fn __init__(inout self, t: TensorF32, layer: Int) raises:\r\n        var elements_per_layer = t.num_elements() // t.dim(0)\r\n        self._data = t.data().offset(layer * elements_per_layer)\r\n        if t.rank() == 2:\r\n            self._shape = TensorShape(t.dim(1))\r\n        elif t.rank() == 3:\r\n            self._shape = TensorShape(t.dim(1), t.dim(2))\r\n        else:\r\n            # Compiler complains if _shape not defined\r\n            self._shape = TensorShape(1)\r\n            raise Error(\"TensorSlice: rank greater than 3 not implemented.\")"
    },
    {
        "text": "    fn simd_load[nelts: Int](self, idx: Int) -> SIMD[DType.float32, nelts]:\r\n        return self._data.simd_load[nelts](idx)"
    },
    {
        "text": "fn read_val_int(inout buf: FileBuf) raises -> Int:\n    # DTypePointer[DType.ui8](buf.data).bitcast[DType.ui8]()\n    var data = buf.data.offset(buf.get_offset()).bitcast[DType.int32]()\n    var result = data.load(0)\n    buf.move_offset(4)\n    return result.to_int()\n"
    },
    {
        "text": "fn read_val_float32(inout buf: FileBuf) raises -> Float32:\r\n    # DTypePointer[DType.ui8](buf.data).bitcast[DType.ui8]()\r\n    var val = buf.data.offset(buf.get_offset()).bitcast[DType.float32]().load(0)\r\n    buf.move_offset(4)\r\n    return val"
    },
    {
        "text": "fn read_val_str(inout buf: FileBuf, slen: Int) raises -> PointerString:\r\n    var str = PointerString.alloc(slen + 1)\r\n    for i in range(slen):\r\n        str.store(i, buf.data.load(buf.get_offset()))\r\n        buf.move_offset(1)\r\n    str.store(slen, 0)\r\n\r\n    return str"
    },
    {
        "text": "fn partition(\n    inout array: PointerStrings, inout indices: DynamicVector[Int], low: Int, high: Int\n) -> Int:\n    var pivot = array[high]\n    var ii = low - 1\n    for jj in range(low, high):\n        if string_compare(pivot, array[jj]) == 1:\n            # If element smaller than pivot, swap\n            ii = ii + 1\n\n            var tmp = array[ii]\n            var tmp_idx = indices[ii]\n            array.store(ii, array[jj])\n            indices[ii] = indices[jj]\n            array.store(jj, tmp)\n            indices[jj] = tmp_idx\n\n    # Swap the pivot element\n    var tmp = array[ii + 1]\n    var tmp_idx = indices[ii + 1]\n    array.store(ii + 1, array[high])\n    indices[ii + 1] = indices[high]\n    array.store(high, tmp)\n    indices[high] = tmp_idx\n\n    return ii + 1\n"
    },
    {
        "text": "fn quicksort(\n    inout array: PointerStrings, inout indices: DynamicVector[Int], low: Int, high: Int\n):\n    if low < high:\n        var pi = partition(array, indices, low, high)\n        quicksort(array, indices, low, pi - 1)\n        quicksort(array, indices, pi + 1, high)"
    },
    {
        "text": "    fn move_offset(inout self, size: Int) raises:\r\n        var new_offset = self.offset + size\r\n        if new_offset > self.size:\r\n            raise Error(\"Resulting offset will be past the end of the FileBuf\")\r\n        if new_offset < 0:\r\n            raise Error(\"Resulting offset will be before the beginning of the FileBuf\")\r\n        self.offset = new_offset"
    },
    {
        "text": "    fn bitcast_offset_f32(inout self, size: Int) raises -> BufferPtrFloat32:\r\n        var ret = self.data.offset(self.offset).bitcast[DType.float32]()\r\n        self.move_offset(size * sizeof[DType.float32]())\r\n        return ret"
    },
    {
        "text": "    fn get_offset(self) raises -> Int:\n        if self.offset > self.size:\n            raise Error(\"Offset is past the end of the FileBuf\")\n        if self.offset < 0:\n            raise Error(\"Offset is before the beginning of the FileBuf\")\n        return self.offset\n"
    },
    {
        "text": "struct Tokenizer:\n    var vocab: PointerStrings\n    var vocab_scores: BufferPtrFloat32\n    var max_token_length: Int\n    var vocab_size: Int\n    var sorted_vocab: PointerStrings\n    var sorted_indices: DynamicVector[Int]\n\n    fn __init__(inout self, vocab_size: Int, inout buf: FileBuf) raises -> None:\n        self.vocab_size = vocab_size\n        self.max_token_length = read_val_int(buf)\n        self.vocab_scores = BufferPtrFloat32.alloc(self.vocab_size)\n        self.vocab = PointerStrings.alloc(self.vocab_size)\n        self.sorted_vocab = PointerStrings.alloc(0)\n        self.sorted_indices = DynamicVector[Int]()\n\n        for i in range(0, self.vocab_size):\n            var score = read_val_float32(buf)\n            var slen = read_val_int(buf)\n            var token = read_val_str(buf, slen)\n            self.store_token(i, token, score)\n        return None"
    },
    {
        "text": "    fn __del__(owned self):\n        for i in range(0, self.vocab_size):\n            self.vocab[i].free()\n        self.vocab.free()\n        self.vocab_scores.free()\n        self.sorted_vocab.free()\n"
    },
    {
        "text": "fn sort(inout self) -> None:\r\n        if len(self.sorted_indices) < self.vocab_size:\r\n            self.sorted_indices = DynamicVector[Int](capacity=self.vocab_size)\r\n            self.sorted_vocab = PointerStrings.alloc(self.vocab_size)\r\n            for ii in range(self.vocab_size):\r\n                self.sorted_vocab.store(ii, self.vocab[ii])\r\n                self.sorted_indices.push_back(ii)\r\n\r\n        var n = self.vocab_size\r\n        quicksort(self.sorted_vocab, self.sorted_indices, 0, n - 1)\r\n        return None"
    },
    {
        "text": "\r\n    fn find(inout self, token_o: PointerString) -> Int:\r\n        var token = wrap(token_o)\r\n        var n = self.vocab_size\r\n        if len(self.sorted_indices) < n:\r\n            self.sort()\r\n        var left = 0\r\n        var right = n - 1\r\n        while left <= right:\r\n            var mid = left + (right - left) // 2\r\n            var comparison = string_compare(self.sorted_vocab[mid], token)\r\n            if comparison == 0:\r\n                return self.sorted_indices[mid]\r\n            if comparison < 0:\r\n                left = mid + 1\r\n            else:\r\n                right = mid - 1\r\n        return -1"
    },
    {
        "text": "@always_inline\nfn accum(inout a: TensorF32, b: TensorF32) -> None:\n    var size = a.dim(0)\n\n    @parameter\n    fn _acc[_nelts: Int](j: Int):\n        a.simd_store[_nelts](j, a.simd_load[_nelts](j) + b.simd_load[_nelts](j))\n\n    vectorize[_acc, nelts](size)"
    },
    {
        "text": "@always_inline\r\nfn softmax(inout x: TensorF32) -> None:\r\n    softmax(x, 0, x.dim(0))"
    },
    {
        "text": "@always_inline\nfn rope_rotation_llama(\n    inout state: RunState,\n    freq_cis_real_row: TensorSlice,\n    freq_cis_imag_row: TensorSlice,\n    config: Config,\n) -> None:\n    # stories model, llama2\n    var head_size = config.head_size"
    },
    {
        "text": "    @parameter\n    fn head_loop(i: Int):\n\n        for j in range(0, config.head_size, 2):\n            var fcr = freq_cis_real_row[j // 2]\n            var fci = freq_cis_imag_row[j // 2]\n            var q0 = state.q[i * head_size + j]\n            var q1 = state.q[i * head_size + j + 1]\n            state.q[i * head_size + j] = q0 * fcr - q1 * fci\n            state.q[i * head_size + j + 1] = q0 * fci + q1 * fcr\n            if i < config.n_kv_heads:\n                var k0 = state.k[i * head_size + j]\n                var k1 = state.k[i * head_size + j + 1]\n                state.k[i * head_size + j] = k0 * fcr - k1 * fci\n                state.k[i * head_size + j + 1] = k0 * fci + k1 * fcr"
    },
    {
        "text": "fn argmax(v: TensorF32) -> Int:\n  \n    var max_i: Int = 0\n    var max_p: Float32 = v[0]\n    for i in range(v.dim(0)):\n        if v[i] > max_p:\n            max_i = i\n            max_p = v[i]\n    return max_i\n"
    },
    {
        "text": "fn sample(probabilities: TensorF32) -> Int:\n    var n = probabilities.dim(0)\n    # Sample index from probabilities, they must sum to 1\n    # get random value within (min, max) float32 range\n    var r = rand[DType.float32](1)\n    var cdf: Float32 = 0.0\n    for i in range(n):\n        cdf += probabilities[i]\n        if r[0] < cdf:\n            return i\n    return n - 1  # In case of rounding errors\n"
    },
    {
        "text": "from time import now\n\nfrom algorithm import sum\nfrom benchmark import Unit, benchmark, keep\nfrom buffer import Buffer\nfrom tensor import Tensor\nfrom python import Python\nfrom tensor import rand\n\nalias size_small: Int = 1 << 21\nalias size_large: Int = 1 << 27\nalias type = DType.float32\n\n\nfn stdlib_reduce_sum[size: Int](array: Tensor[type]) -> Float32:\n    var my_sum = sum(array._to_buffer())\n    return my_sum\n\n\nfn bench[\n    func: fn[size: Int] (array: Tensor[type]) -> Float32,\n    size: Int,\n    name: StringLiteral,\n](array: Tensor[type]) raises:\n    @parameter\n    fn runner():\n        var result = func[size](array)\n        keep(result)\n\n    var ms = benchmark.run[runner](max_runtime_secs=0.5).mean(Unit.ms)\n    pretty_print(name, size, ms)\n\n\nfn main() raises:\n    var small_array = rand[type](size_small)\n    var large_array = rand[type](size_large)\n\n    bench[naive_reduce_sum, size_small, \"naive\"](small_array)\n    bench[naive_reduce_sum, size_large, \"naive\"](large_array)\n\n    bench[stdlib_reduce_sum, size_small, \"stdlib\"](small_array)\n    bench[stdlib_reduce_sum, size_large, \"stdlib\"](large_array)"
    },
    {
        "text": "fn pretty_print(name: StringLiteral, elements: Int, time: Float64) raises:\r\n    var py = Python.import_module(\"builtins\")\r\n    _ = py.print(\r\n        py.str(\"{:<16} {:>11,} {:>8.2f}ms\").format(\r\n            String(name) + \" elements:\", elements, time\r\n        )\r\n    )"
    },
    {
        "text": "\nfn naive_reduce_sum[size: Int](array: Tensor[type]) -> Float32:\n    var A = array\n    var my_sum = array[0]\n    var c: Float32 = 0.0\n    for i in range(array.dim(0)):\n        var y = array[i] - c\n        var t = my_sum + y\n        c = (t - my_sum) - y\n        my_sum = t\n    return my_sum"
    },
    {
        "text": "from sys.info import *\nfrom sys.info import _current_cpu, _current_target, _triple_attr\n\n\ndef main():\n    var os = \"\"\n    if os_is_linux():\n        os = \"linux\"\n    elif os_is_macos():\n        os = \"macOS\"\n    else:\n        os = \"windows\"\n    var cpu = String(_current_cpu())\n    var arch = String(_triple_attr())\n\n    print(\"System information: \")\n    print(\"    OS             : \", os)\n    print(\"    CPU            : \", cpu)\n    print(\"    Arch           : \", arch)\n\n  \n"
    },
    {
        "text": "@always_inline(\"nodebug\")\r\nfn _digits[type: DType]() -> Int:\r\n\r\n    alias mlir_type = __mlir_type[`!pop.scalar<`, type.value, `>`]\r\n\r\n    @parameter\r\n    if type == DType.bool:\r\n        return 1\r\n\r\n    @parameter\r\n    if type.is_integral():\r\n        var bitwidth = bitwidthof[mlir_type]()\r\n        return bitwidth - 1 if type.is_signed() else bitwidth\r\n\r\n    @parameter\r\n    if type == DType.float16:\r\n        return 11\r\n\r\n    @parameter\r\n    if type == DType.bfloat16:\r\n        return 8\r\n\r\n    @parameter\r\n    if type == DType.float32:\r\n        return 24\r\n\r\n    @parameter\r\n    if type == DType.float64:\r\n        return 53\r\n    # Unreachable.\r\n    return -1"
    },
    {
        "text": "@always_inline\r\nfn _fp_bitcast_to_integer[type: DType](value: Scalar[type]) -> Int:\r\n\r\n    alias integer_type = _integral_type_of[type]()\r\n    return int(bitcast[integer_type, 1](value))\r\n"
    },
    {
        "text": "@always_inline\r\nfn _fp_bitcast_from_integer[type: DType](value: Int) -> Scalar[type]:\r\n\r\n    alias integer_type = _integral_type_of[type]()\r\n    var int_val = SIMD[integer_type, 1](value)\r\n    return bitcast[type, 1](int_val)"
    },
    {
        "text": " @staticmethod\r\n    @always_inline(\"nodebug\")\r\n    fn max_exponent() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n\r\n        @parameter\r\n        if type == DType.float16:\r\n            return 16\r\n        elif type == DType.float32 or type == DType.bfloat16:\r\n            return 128\r\n\r\n        debug_assert(type == DType.float64, \"must be float64\")\r\n        return 1024\r\n"
    },
    {
        "text": " @staticmethod\r\n    @always_inline(\"nodebug\")\r\n    fn exponent_width() -> Int:\r\n        \r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n\r\n        @parameter\r\n        if type == DType.float16:\r\n            return 5\r\n        elif type == DType.float32 or type == DType.bfloat16:\r\n            return 8\r\n\r\n        debug_assert(type == DType.float64, \"must be float64\")\r\n        return 11\r\n"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn mantissa_mask() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return (1 << Self.mantissa_width()) - 1"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn exponent_bias() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return Self.max_exponent() - 1"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn sign_mask() -> Int:\r\n\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return 1 << (Self.exponent_width() + Self.mantissa_width())"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn exponent_mantissa_mask() -> Int:\r\n\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return Self.exponent_mask() + Self.mantissa_mask()"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn quiet_nan_mask() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        var mantissa_width_val = Self.mantissa_width()\r\n        return (1 << Self.exponent_width() - 1) << mantissa_width_val + (\r\n            1 << (mantissa_width_val - 1)\r\n        )"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn bitcast_to_integer(value: Scalar[type]) -> Int:\r\n\r\n        return _fp_bitcast_to_integer[type](value)"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn bitcast_from_integer(value: Int) -> Scalar[type]:\r\n\r\n        return _fp_bitcast_from_integer[type](value)"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn get_sign(value: Scalar[type]) -> Bool:\r\n\r\n\r\n        return (Self.bitcast_to_integer(value) & Self.sign_mask()) != 0"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn set_sign(value: Scalar[type], sign: Bool) -> Scalar[type]:\r\n\r\n        var bits = Self.bitcast_to_integer(value)\r\n        var sign_bits = Self.sign_mask()\r\n        bits &= ~sign_bits\r\n        if sign:\r\n            bits |= sign_bits\r\n        return Self.bitcast_from_integer(bits)"
    },
    {
        "text": "    @staticmethod\r\n    @always_inline\r\n    fn get_exponent_without_bias(value: Scalar[type]) -> Int:\r\n\r\n\r\n        return Self.get_exponent(value) - Self.exponent_bias()"
    },
    {
        "text": "    @staticmethod\n    @always_inline\n    fn set_exponent(value: Scalar[type], exponent: Int) -> Scalar[type]:\n\n        var bits = Self.bitcast_to_integer(value)\n        bits &= ~Self.exponent_mask()\n        bits |= (exponent << Self.mantissa_width()) & Self.exponent_mask()\n        return Self.bitcast_from_integer(bits)"
    },
    {
        "text": "@always_inline(\"nodebug\")\r\nfn isinf[\r\n    type: DType, simd_width: Int\r\n](val: SIMD[type, simd_width]) -> SIMD[DType.bool, simd_width]:\r\n\r\n\r\n    @parameter\r\n    if not type.is_floating_point():\r\n        return False\r\n\r\n    alias negative_infinity_test: UInt32 = 0x0004\r\n    alias positive_infinity_test: UInt32 = 0x0200\r\n    return llvm_intrinsic[\"llvm.is.fpclass\", SIMD[DType.bool, simd_width]](\r\n        val.value, (negative_infinity_test | positive_infinity_test).value\r\n    )"
    },
    {
        "text": "@always_inline(\"nodebug\")\r\nfn isnan[\r\n    type: DType, simd_width: Int\r\n](val: SIMD[type, simd_width]) -> SIMD[DType.bool, simd_width]:\r\n\r\n\r\n    @parameter\r\n    if not type.is_floating_point():\r\n        return False\r\n\r\n    @parameter\r\n    if type == DType.bfloat16:\r\n        alias int_dtype = _integral_type_of[type]()\r\n        var int_val = bitcast[int_dtype, simd_width](val)\r\n        return int_val & SIMD[int_dtype, simd_width](0x7FFF) > SIMD[\r\n            int_dtype, simd_width\r\n        ](0x7F80)\r\n\r\n    alias signaling_nan_test: UInt32 = 0x0001\r\n    alias quiet_nan_test: UInt32 = 0x0002\r\n    return llvm_intrinsic[\"llvm.is.fpclass\", SIMD[DType.bool, simd_width]](\r\n        val.value, (signaling_nan_test | quiet_nan_test).value\r\n    )\r\n"
    },
    {
        "text": "@always_inline\nfn _reduce_and_fn(a: Bool, b: Bool) -> Bool:\n\n    return a and b"
    },
    {
        "text": "@always_inline\r\nfn _int_tuple_binary_apply[\r\n    size: Int,\r\n    binary_fn: fn (Int, Int) -> Int,\r\n](a: StaticTuple[Int, size], b: StaticTuple[Int, size]) -> StaticTuple[\r\n    Int, size\r\n]:\r\n\r\n\r\n    var c = StaticTuple[Int, size]()\r\n\r\n    @always_inline\r\n    @parameter\r\n    fn do_apply[idx: Int]():\r\n        var a_elem: Int = a.__getitem__[idx]()\r\n        var b_elem: Int = b.__getitem__[idx]()\r\n        c.__setitem__[idx](binary_fn(a_elem, b_elem))\r\n\r\n    unroll[do_apply, size]()\r\n\r\n    return c"
    },
    {
        "text": "@always_inline\r\nfn _int_tuple_compare[\r\n    size: Int,\r\n    comp_fn: fn (Int, Int) -> Bool,\r\n](a: StaticTuple[Int, size], b: StaticTuple[Int, size]) -> StaticTuple[\r\n    mlir_bool,\r\n    size,\r\n]:\r\n\r\n\r\n    var c = StaticTuple[mlir_bool, size]()\r\n\r\n    @always_inline\r\n    @parameter\r\n    fn do_compare[idx: Int]():\r\n        var a_elem: Int = a.__getitem__[idx]()\r\n        var b_elem: Int = b.__getitem__[idx]()\r\n        c.__setitem__[idx](comp_fn(a_elem, b_elem).value)\r\n\r\n    unroll[do_compare, size]()\r\n\r\n    return c\r\n"
    },
    {
        "text": " @always_inline\n    fn __init__() -> Self:\n\n        return 0\n"
    },
    {
        "text": "    @always_inline\r\n    fn __init__(value: __mlir_type.index) -> Self:\r\n\r\n        constrained[size == 1]()\r\n        return Int(value)"
    },
    {
        "text": " @always_inline\r\n    fn __init__(elems: Tuple[Int, Int]) -> Self:\r\n\r\n\r\n        var num_elements = len(elems)\r\n\r\n        debug_assert(\r\n            size == num_elements,\r\n            \"[StaticIntTuple] mismatch in the number of elements\",\r\n        )\r\n\r\n        var tup = Self()\r\n\r\n        @parameter\r\n        fn fill[idx: Int]():\r\n            tup[idx] = elems.get[idx, Int]()\r\n\r\n        unroll[fill, 2]()\r\n\r\n        return tup"
    },
    {
        "text": "@always_inline\r\n    fn __init__(elems: Tuple[Int, Int, Int, Int]) -> Self:\r\n\r\n\r\n        var num_elements = len(elems)\r\n\r\n        debug_assert(\r\n            size == num_elements,\r\n            \"[StaticIntTuple] mismatch in the number of elements\",\r\n        )\r\n\r\n        var tup = Self()\r\n\r\n        @parameter\r\n        fn fill[idx: Int]():\r\n            tup[idx] = elems.get[idx, Int]()\r\n\r\n        unroll[fill, 4]()\r\n\r\n        return tup\r\n"
    },
    {
        "text": "@always_inline\nfn Index[\n    T0: Intable, T1: Intable, T2: Intable\n](x: T0, y: T1, z: T2) -> StaticIntTuple[3]:\n\n    return StaticIntTuple[3](int(x), int(y), int(z))"
    },
    {
        "text": "@always_inline\nfn Index[\n    T0: Intable, T1: Intable, T2: Intable, T3: Intable\n](x: T0, y: T1, z: T2, w: T3) -> StaticIntTuple[4]:\n\n    return StaticIntTuple[4](int(x), int(y), int(z), int(w))"
    },
    {
        "text": "@always_inline\r\nfn Index[\r\n    T0: Intable, T1: Intable, T2: Intable, T3: Intable, T4: Intable\r\n](x: T0, y: T1, z: T2, w: T3, v: T4) -> StaticIntTuple[5]:\r\n\r\n    return StaticIntTuple[5](int(x), int(y), int(z), int(w), int(v))"
    },
    {
        "text": "@always_inline\r\nfn now() -> Int:\r\n\r\n    return _monotonic_nanoseconds()\r\n"
    },
    {
        "text": "@always_inline\r\n@parameter\r\nfn time_function[func: fn () capturing -> None]() -> Int:\r\n\r\n\r\n    @parameter\r\n    if os_is_windows():\r\n        return _time_function_windows[func]()\r\n\r\n    var tic = now()\r\n    func()\r\n    var toc = now()\r\n    return toc - tic"
    },
    {
        "text": "fn sleep(sec: Float64):\r\n\r\n    alias NANOSECONDS_IN_SECOND = 1_000_000_000\r\n    var total_secs = _floor(sec)\r\n    var tv_spec = _CTimeSpec(\r\n        int(total_secs.cast[DType.index]()),\r\n        int((sec - total_secs) * NANOSECONDS_IN_SECOND),\r\n    )\r\n    var req = Pointer[_CTimeSpec].address_of(tv_spec)\r\n    var rem = Pointer[_CTimeSpec].get_null()\r\n    _ = external_call[\"nanosleep\", Int32](req, rem)"
    },
    {
        "text": "fn sleep(sec: Int):\r\n\r\n\r\n    @parameter\r\n    if os_is_windows():\r\n        # In Windows the argument is in milliseconds.\r\n        external_call[\"Sleep\", NoneType](sec * 1000)\r\n    else:\r\n        external_call[\"sleep\", NoneType](sec)"
    },
    {
        "text": "fn b64encode(str: String) -> String:\n\n    alias lookup = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    var b64chars = lookup.data()\n\n    var length = len(str)\n    var out = List[Int8](capacity=length + 1)\n\n    @parameter\n    @always_inline\n    fn s(idx: Int) -> Int:\n        return int(str._buffer[idx])\n\n    var end = length - (length % 3)\n    for i in range(0, end, 3):\n        var si = s(i)\n        var si_1 = s(i + 1)\n        var si_2 = s(i + 2)\n        out.append(b64chars.load(si // 4))\n        out.append(b64chars.load(((si * 16) % 64) + si_1 // 16))\n        out.append(b64chars.load(((si_1 * 4) % 64) + si_2 // 64))\n        out.append(b64chars.load(si_2 % 64))\n\n    var i = end\n    if i < length:\n        var si = s(i)\n        out.append(b64chars.load(si // 4))\n        if i == length - 1:\n            out.append(b64chars.load((si * 16) % 64))\n            out.append(ord(\"=\"))\n        elif i == length - 2:\n            var si_1 = s(i + 1)\n            out.append(b64chars.load(((si * 16) % 64) + si_1 // 16))\n            out.append(b64chars.load((si_1 * 4) % 64))\n        out.append(ord(\"=\"))\n    out.append(0)\n    return String(out ^)"
    },
    {
        "text": "@value\nstruct _DictKeyIter[\n    K: KeyElement,\n    V: CollectionElement,\n    dict_mutability: __mlir_type.`i1`,\n    dict_lifetime: AnyLifetime[dict_mutability].type,\n]:\n\n\n    alias imm_dict_lifetime = __mlir_attr[\n        `#lit.lifetime.mutcast<`, dict_lifetime, `> : !lit.lifetime<1>`\n    ]\n    alias ref_type = Reference[K, __mlir_attr.`0: i1`, Self.imm_dict_lifetime]\n\n    var iter: _DictEntryIter[K, V, dict_mutability, dict_lifetime]\n\n    fn __iter__(self) -> Self:\n        return self\n\n    fn __next__(inout self) -> Self.ref_type:\n        var entry_ref = self.iter.__next__()\n        var mlir_ptr = __mlir_op.`lit.ref.to_pointer`(\n            Reference(entry_ref[].key).value\n        )\n        var key_ptr = AnyPointer[K] {\n            value: __mlir_op.`pop.pointer.bitcast`[\n                _type = AnyPointer[K].pointer_type\n            ](mlir_ptr)\n        }\n        return __mlir_op.`lit.ref.from_pointer`[\n            _type = Self.ref_type.mlir_ref_type\n        ](key_ptr.value)\n\n    fn __len__(self) -> Int:\n        return self.iter.__len__()"
    },
    {
        "text": "@value\nstruct _DictValueIter[\n    K: KeyElement,\n    V: CollectionElement,\n    dict_mutability: __mlir_type.`i1`,\n    dict_lifetime: AnyLifetime[dict_mutability].type,\n]:\n\n\n    alias ref_type = Reference[V, dict_mutability, dict_lifetime]\n\n    var iter: _DictEntryIter[K, V, dict_mutability, dict_lifetime]\n\n    fn __iter__(self) -> Self:\n        return self\n\n    fn __next__(inout self) -> Self.ref_type:\n        var entry_ref = self.iter.__next__()\n        var mlir_ptr = __mlir_op.`lit.ref.to_pointer`(\n            Reference(entry_ref[].value).value\n        )\n        var value_ptr = AnyPointer[V] {\n            value: __mlir_op.`pop.pointer.bitcast`[\n                _type = AnyPointer[V].pointer_type\n            ](mlir_ptr)\n        }\n        return __mlir_op.`lit.ref.from_pointer`[\n            _type = Self.ref_type.mlir_ref_type\n        ](value_ptr.value)\n\n    fn __len__(self) -> Int:\n        return self.iter.__len__()"
    },
    {
        "text": "@value\nstruct DictEntry[K: KeyElement, V: CollectionElement](CollectionElement):\n\n    var hash: Int\n    var key: K \n    var value: V\n  \n\n    fn __init__(inout self, owned key: K, owned value: V):\n        self.hash = hash(key)\n        self.key = key ^\n        self.value = value ^\n"
    },
    {
        "text": "    fn __init__(inout self, reserved: Int):\n        if reserved <= 128:\n            var data = DTypePointer[DType.int8].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()\n        elif reserved <= 2**16 - 2:\n            var data = DTypePointer[DType.int16].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()\n        elif reserved <= 2**32 - 2:\n            var data = DTypePointer[DType.int32].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()\n        else:\n            var data = DTypePointer[DType.int64].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()"
    },
    {
        "text": "    fn copy(self, reserved: Int) -> Self:\n        var index = Self(reserved)\n        if reserved <= 128:\n            var data = self.data.bitcast[DType.int8]()\n            var new_data = index.data.bitcast[DType.int8]()\n            memcpy(new_data, data, reserved)\n        elif reserved <= 2**16 - 2:\n            var data = self.data.bitcast[DType.int16]()\n            var new_data = index.data.bitcast[DType.int16]()\n            memcpy(new_data, data, reserved)\n        elif reserved <= 2**32 - 2:\n            var data = self.data.bitcast[DType.int32]()\n            var new_data = index.data.bitcast[DType.int32]()\n            memcpy(new_data, data, reserved)\n        else:\n            var data = self.data.bitcast[DType.int64]()\n            var new_data = index.data.bitcast[DType.int64]()\n            memcpy(new_data, data, reserved)\n        return index ^"
    },
    {
        "text": "    fn get_index(self, reserved: Int, slot: Int) -> Int:\n        if reserved <= 128:\n            var data = self.data.bitcast[DType.int8]()\n            return data.load(slot % reserved).to_int()\n        elif reserved <= 2**16 - 2:\n            var data = self.data.bitcast[DType.int16]()\n            return data.load(slot % reserved).to_int()\n        elif reserved <= 2**32 - 2:\n            var data = self.data.bitcast[DType.int32]()\n            return data.load(slot % reserved).to_int()\n        else:\n            var data = self.data.bitcast[DType.int64]()\n            return data.load(slot % reserved).to_int()"
    },
    {
        "text": "    fn set_index(inout self, reserved: Int, slot: Int, value: Int):\r\n        if reserved <= 128:\r\n            var data = self.data.bitcast[DType.int8]()\r\n            return data.store(slot % reserved, value)\r\n        elif reserved <= 2**16 - 2:\r\n            var data = self.data.bitcast[DType.int16]()\r\n            return data.store(slot % reserved, value)\r\n        elif reserved <= 2**32 - 2:\r\n            var data = self.data.bitcast[DType.int32]()\r\n            return data.store(slot % reserved, value)\r\n        else:\r\n            var data = self.data.bitcast[DType.int64]()\r\n            return data.store(slot % reserved, value)"
    },
    {
        "text": "var size: Int"
    },
    {
        "text": "var _n_entries: Int"
    },
    {
        "text": "var _reserved: Int"
    },
    {
        "text": "    fn __init__(inout self):\n\n        self.size = 0\n        self._n_entries = 0\n        self._reserved = 8\n        self._index = _DictIndex(self._reserved)\n        self._entries = Self._new_entries(self._reserved)"
    },
    {
        "text": "    fn __init__(inout self, existing: Self):\n\n        self.size = existing.size\n        self._n_entries = existing._n_entries\n        self._reserved = existing._reserved\n        self._index = existing._index.copy(existing._reserved)\n        self._entries = existing._entries"
    },
    {
        "text": "    fn __copyinit__(inout self, existing: Self):\n\n        self.size = existing.size\n        self._n_entries = existing._n_entries\n        self._reserved = existing._reserved\n        self._index = existing._index.copy(existing._reserved)\n        self._entries = existing._entries"
    },
    {
        "text": "    fn __moveinit__(inout self, owned existing: Self):\n\n        self.size = existing.size\n        self._n_entries = existing._n_entries\n        self._reserved = existing._reserved\n        self._index = existing._index ^\n        self._entries = existing._entries ^"
    },
    {
        "text": "    fn __getitem__(self, key: K) raises -> V:\n\n        var value = self.find(key)\n        if value:\n            return value.value()\n        raise \"KeyError\""
    },
    {
        "text": "    fn __setitem__(inout self, key: K, value: V):\r\n\r\n        self._insert(key, value)"
    },
    {
        "text": "    fn __contains__(self, key: K) -> Bool:\n\n        return self.find(key).__bool__()"
    },
    {
        "text": "    fn __len__(self) -> Int:\r\n       \r\n        return self.size"
    },
    {
        "text": "    fn find(self, key: K) -> Optional[V]:\r\n \r\n        var hash = hash(key)\r\n        var found: Bool\r\n        var slot: Int\r\n        var index: Int\r\n        found, slot, index = self._find_index(hash, key)\r\n        if found:\r\n            var ev = self._entries.__get_ref(index)[]\r\n            debug_assert(ev.__bool__(), \"entry in index must be full\")\r\n            return ev.value().value\r\n        return None"
    },
    {
        "text": "    fn pop(inout self, key: K, owned default: Optional[V] = None) raises -> V:\r\n \r\n        var hash = hash(key)\r\n        var found: Bool\r\n        var slot: Int\r\n        var index: Int\r\n        found, slot, index = self._find_index(hash, key)\r\n        if found:\r\n            self._set_index(slot, Self.REMOVED)\r\n            var entry = self._entries.__get_ref(index)[]\r\n            self._entries[index] = None\r\n            self.size -= 1\r\n            debug_assert(entry.__bool__(), \"entry in index must be full\")\r\n            return entry.value().value\r\n        elif default:\r\n            return default.value()\r\n        raise \"KeyError\""
    },
    {
        "text": "    fn __iter__[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _DictKeyIter[K, V, mutability, self_life]:\r\n\r\n        return _DictKeyIter(\r\n            _DictEntryIter[K, V, mutability, self_life](0, 0, Reference(self))\r\n        )"
    },
    {
        "text": "    fn keys[\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\n    ](\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\n    ) -> _DictKeyIter[K, V, mutability, self_life]:\n\n        return Self.__iter__(self)"
    },
    {
        "text": "    fn values[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _DictValueIter[K, V, mutability, self_life]:\r\n\r\n        return _DictValueIter(\r\n            _DictEntryIter[K, V, mutability, self_life](0, 0, Reference(self))\r\n        )"
    },
    {
        "text": "    fn items[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _DictEntryIter[K, V, mutability, self_life]:\r\n\r\n        return _DictEntryIter[K, V, mutability, self_life](\r\n            0, 0, Reference(self)\r\n        )"
    },
    {
        "text": "    @staticmethod\r\n    fn _new_entries(reserved: Int) -> List[Optional[DictEntry[K, V]]]:\r\n        var entries = List[Optional[DictEntry[K, V]]](capacity=reserved)\r\n        for i in range(reserved):\r\n            entries.append(None)\r\n        return entries"
    },
    {
        "text": "    fn _insert(inout self, owned key: K, owned value: V):\r\n        self._insert(DictEntry[K, V](key ^, value ^))"
    },
    {
        "text": "    fn _insert(inout self, owned entry: DictEntry[K, V]):\r\n        self._maybe_resize()\r\n        var found: Bool\r\n        var slot: Int\r\n        var index: Int\r\n        found, slot, index = self._find_index(entry.hash, entry.key)\r\n\r\n        self._entries[index] = entry ^\r\n        if not found:\r\n            self._set_index(slot, index)\r\n            self.size += 1\r\n            self._n_entries += 1"
    },
    {
        "text": "    fn _get_index(self, slot: Int) -> Int:\r\n        return self._index.get_index(self._reserved, slot)"
    },
    {
        "text": "    fn _set_index(inout self, slot: Int, index: Int):\n        return self._index.set_index(self._reserved, slot, index)"
    },
    {
        "text": "    fn _next_index_slot(self, inout slot: Int, inout perturb: Int):\r\n        alias PERTURB_SHIFT = 5\r\n        perturb >>= PERTURB_SHIFT\r\n        slot = ((5 * slot) + perturb + 1) % self._reserved"
    },
    {
        "text": "    fn _find_empty_index(self, hash: Int) -> Int:\r\n        var slot = hash % self._reserved\r\n        var perturb = hash\r\n        for _ in range(self._reserved):\r\n            var index = self._get_index(slot)\r\n            if index == Self.EMPTY:\r\n                return slot\r\n            self._next_index_slot(slot, perturb)\r\n        abort(\"Dict: no empty index in _find_empty_index\")\r\n        return 0\r"
    },
    {
        "text": "    fn _over_load_factor(self) -> Bool:\r\n        return 3 * self.size > 2 * self._reserved\r"
    },
    {
        "text": "    fn _over_compact_factor(self) -> Bool:\r\n        return 4 * self._n_entries > 3 * self._reserved"
    },
    {
        "text": "    fn _maybe_resize(inout self):\n        if not self._over_load_factor():\n            if self._over_compact_factor():\n                self._compact()\n            return\n        self._reserved *= 2\n        self.size = 0\n        self._n_entries = 0\n        self._index = _DictIndex(self._reserved)\n        var old_entries = self._entries ^\n        self._entries = self._new_entries(self._reserved)\n\n        for i in range(len(old_entries)):\n            var entry = old_entries.__get_ref(i)[]\n            if entry:\n                self._insert(entry.value())"
    },
    {
        "text": "    fn _compact(inout self):\n        self._index = _DictIndex(self._reserved)\n        var right = 0\n        for left in range(self.size):\n            while not self._entries.__get_ref(right)[]:\n                right += 1\n                debug_assert(right < self._reserved, \"Invalid dict state\")\n            var entry = self._entries.__get_ref(right)[]\n            debug_assert(entry.__bool__(), \"Logic error\")\n            var slot = self._find_empty_index(entry.value().hash)\n            self._set_index(slot, left)\n            if left != right:\n                self._entries[left] = entry\n                self._entries[right] = None\n\n        self._n_entries = self.size"
    },
    {
        "text": "var data: AnyPointer[T]"
    },
    {
        "text": "var size: Int"
    },
    {
        "text": "var capacity: Int"
    },
    {
        "text": "    fn __init__(inout self):\r\n       \r\n        self.data = AnyPointer[T]()\r\n        self.size = 0\r\n        self.capacity = 0"
    },
    {
        "text": "    fn __init__(inout self, existing: Self):\r\n\r\n        self.__init__(capacity=existing.capacity)\r\n        for e in existing:\r\n            self.append(e[])"
    },
    {
        "text": "    fn __init__(inout self, *, capacity: Int):\n\n        self.data = AnyPointer[T].alloc(capacity)\n        self.size = 0\n        self.capacity = capacity"
    },
    {
        "text": "    fn __init__(inout self, *values: T):\r\n\r\n        self = Self(capacity=len(values))\r\n        for value in values:\r\n            self.append(value[])"
    },
    {
        "text": "    fn __moveinit__(inout self, owned existing: Self):\n \n        self.data = existing.data\n        self.size = existing.size\n        self.capacity = existing.capacity"
    },
    {
        "text": "    fn __copyinit__(inout self, existing: Self):\r\n\r\n        self = Self(capacity=existing.capacity)\r\n        for i in range(len(existing)):\r\n            self.append(existing[i])"
    },
    {
        "text": "    fn __del__(owned self):\r\n\r\n        for i in range(self.size):\r\n            _ = (self.data + i).take_value()\r\n        if self.data:\r\n            self.data.free()"
    },
    {
        "text": "    fn __len__(self) -> Int:\r\n\r\n        return self.size"
    },
    {
        "text": "    fn _realloc(inout self, new_capacity: Int):\r\n        var new_data = AnyPointer[T].alloc(new_capacity)\r\n\r\n        for i in range(self.size):\r\n            (new_data + i).emplace_value((self.data + i).take_value())\r\n\r\n        if self.data:\r\n            self.data.free()\r\n        self.data = new_data\r\n        self.capacity = new_capacity"
    },
    {
        "text": "    fn append(inout self, owned value: T):\r\n\r\n        if self.size >= self.capacity:\r\n            self._realloc(_max(1, self.capacity * 2))\r\n        (self.data + self.size).emplace_value(value ^)\r\n        self.size += 1"
    },
    {
        "text": "    fn pop_back(inout self) -> T:\r\n\r\n        var ret_val = (self.data + (self.size - 1)).take_value()\r\n        self.size -= 1\r\n        if self.size * 4 < self.capacity:\r\n            if self.capacity > 1:\r\n                self._realloc(self.capacity // 2)\r\n        return ret_val ^"
    },
    {
        "text": "    fn reserve(inout self, new_capacity: Int):\r\n\r\n        if self.capacity >= new_capacity:\r\n            return\r\n        self._realloc(new_capacity)"
    },
    {
        "text": "    fn reverse(inout self):\r\n          self._reverse()"
    },
    {
        "text": "    fn clear(inout self):        for i in range(self.size):\n            _ = (self.data + i).take_value()\n        self.size = 0"
    },
    {
        "text": "    fn steal_data(inout self) -> AnyPointer[T]:\r\n\r\n        var ptr = self.data\r\n        self.data = AnyPointer[T]()\r\n        self.size = 0\r\n        self.capacity = 0\r\n        return ptr"
    },
    {
        "text": "    fn __setitem__(inout self, i: Int, owned value: T):\r\n       \r\n        debug_assert(-self.size <= i < self.size, \"index must be within bounds\")\r\n\r\n        var normalized_idx = i\r\n        if i < 0:\r\n            normalized_idx += len(self)\r\n\r\n        _ = (self.data + normalized_idx).take_value()\r\n        (self.data + normalized_idx).emplace_value(value ^)"
    },
    {
        "text": "    @always_inline\r\n    fn _adjust_span(self, span: Slice) -> Slice:\r\n      \r\n        var adjusted_span = span\r\n\r\n        if adjusted_span.start < 0:\r\n            adjusted_span.start = len(self) + adjusted_span.start\r\n\r\n        if not adjusted_span._has_end():\r\n            adjusted_span.end = len(self)\r\n        elif adjusted_span.end < 0:\r\n            adjusted_span.end = len(self) + adjusted_span.end\r\n\r\n        if span.step < 0:\r\n            var tmp = adjusted_span.end\r\n            adjusted_span.end = adjusted_span.start - 1\r\n            adjusted_span.start = tmp - 1\r\n\r\n        return adjusted_span"
    },
    {
        "text": "    @always_inline\r\n    fn __getitem__(self, span: Slice) -> Self:\r\n        \r\n\r\n        var adjusted_span = self._adjust_span(span)\r\n        var adjusted_span_len = len(adjusted_span)\r\n\r\n        if not adjusted_span_len:\r\n            return Self()\r\n\r\n        var res = Self(capacity=len(adjusted_span))\r\n        for i in range(len(adjusted_span)):\r\n            res.append(self[adjusted_span[i]])\r\n\r\n        return res ^"
    },
    {
        "text": "    fn __iter__[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _ListIter[\r\n        T, mutability, self_life\r\n    ]:\r\n       \r\n        return _ListIter[T, mutability, self_life](0, Reference(self))"
    },
    {
        "text": "struct Set[T: KeyElement](Sized, EqualityComparable, Hashable, Boolable):\r\n    "
    },
    {
        "text": "fn __init__(inout self, *ts: T):\r\n\r\n        self._data = Dict[T, NoneType]()\r\n        for t in ts:\r\n            self.add(t[])"
    },
    {
        "text": "    fn __init__(inout self, elements: Self):\r\n \r\n        self.__init__()\r\n        for e in elements:\r\n            self.add(e[])"
    },
    {
        "text": "    fn __init__(inout self, elements: List[T]):\r\n\r\n        self.__init__()\r\n        for e in elements:\r\n            self.add(e[])\r\n"
    },
    {
        "text": "    fn __moveinit__(inout self, owned other: Self):\r\n\r\n        self._data = other._data ^"
    },
    {
        "text": "    fn __contains__(self, t: T) -> Bool:\r\n \r\n        return t in self._data"
    },
    {
        "text": "    fn __bool__(self) -> Bool:\r\n\r\n        return len(self).__bool__()"
    },
    {
        "text": "    fn __hash__(self) -> Int:\n\n        var hash_value = 0\n        # Hash combination needs to be commutative so iteration order\n        # doesn't impact the hash value.\n        for e in self:\n            hash_value ^= hash(e[])\n        return hash_value"
    },
    {
        "text": "    fn __and__(self, other: Self) -> Self:\n\n        return self.intersection(other)"
    },
    {
        "text": "    fn __or__(self, other: Self) -> Self:\r\n       \r\n        return self.union(other)"
    },
    {
        "text": "    fn __ior__(inout self, other: Self):\r\n\r\n        for e in other:\r\n            self.add(e[])"
    },
    {
        "text": "    fn __sub__(self, other: Self) -> Self:\r\n\r\n        var result = Set[T]()\r\n        for e in self:\r\n            if e[] not in other:\r\n                result.add(e[])\r\n        return result ^\r\n"
    },
    {
        "text": "    fn __isub__(inout self, other: Self):\n\n        self.remove_all(other)"
    },
    {
        "text": "    fn add(inout self, t: T):\n\n        self._data[t] = None"
    },
    {
        "text": "    fn remove(inout self, t: T) raises:\n        self._data.pop(t)"
    },
    {
        "text": "    fn pop(inout self) raises -> T:\n\n        if not self:\n            raise \"Pop on empty set\"\n        var iter = self.__iter__()\n        var first = iter.__next__()[]\n        self.remove(first)\n        return first"
    },
    {
        "text": "    fn union(self, other: Self) -> Self:\n\n        var result = Set(self)\n        for o in other:\n            result.add(o[])\n\n        return result ^"
    },
    {
        "text": "    fn intersection(self, other: Self) -> Self:\n\n        var result = Set[T]()\n        for v in self:\n            if v[] in other:\n                result.add(v[])\n\n        return result ^"
    },
    {
        "text": "    fn remove_all(inout self, other: Self):\n\n        for o in other:\n            try:\n                self.remove(o[])\n            except:\n                pass"
    },
    {
        "text": "    var conv_layer_one = Conv2D[\r\n        in_channels=1,\r\n        kernel_width=3,\r\n        kernel_height=3,\r\n        stride=1,\r\n        padding=0,\r\n        weight_initializer = HeUniform[1],\r\n        activation=\"relu\",\r\n    ]()"
    },
    {
        "text": "    var dense2 = Dense[\r\n        in_neurons=100,\r\n        out_neurons=10,\r\n        activation=\"sigmoid\",\r\n    ]()"
    },
    {
        "text": "var true_vals = Tensor[TensorShape(batches, 10), Zeros]()"
    },
    {
        "text": " var input = Tensor[TensorShape(batches, channels, width, height), Zeros]()"
    },
    {
        "text": "var epoch_start = now()"
    },
    {
        "text": "    for epoch in range(1, num_epochs + 1):\n        for i in range(batches):\n            var image = dataset.train_images[i + epoch * batches]\n            var label = dataset.train_labels[i + epoch * batches].to_int()\n            true_vals[i * 10 + label] = 1.0\n            for j in range(width):\n                for k in range(height):\n                    input[i * channels * width * height + j * width + k] = image[\n                        j * width + k\n                    ].to_int()"
    },
    {
        "text": "    @always_inline\n    fn __init__(inout self, value: Scalar[type]):\n\n        self.value = value"
    },
    {
        "text": "    @always_inline\r\n    fn __init__(inout self, value: Int):\r\n \r\n        self.__init__(Scalar[type](value))"
    },
    {
        "text": "    @staticmethod\n    @always_inline\n    fn _fetch_add(\n        ptr: Pointer[Scalar[type]], rhs: Scalar[type]\n    ) -> Scalar[type]:\n\n        return __mlir_op.`pop.atomic.rmw`[\n            bin_op = __mlir_attr.`#pop<bin_op add>`,\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\n        ](\n            bitcast[__mlir_type[`!pop.scalar<`, type.value, `>`]](ptr).address,\n            rhs.value,\n        )"
    },
    {
        "text": "    @always_inline\r\n    fn fetch_add(inout self, rhs: Scalar[type]) -> Scalar[type]:\r\n\r\n        var value_addr = Pointer.address_of(self.value)\r\n        return Self._fetch_add(value_addr, rhs)"
    },
    {
        "text": "    @always_inline\r\n    fn __iadd__(inout self, rhs: Scalar[type]):\r\n\r\n        _ = self.fetch_add(rhs)"
    },
    {
        "text": "    @always_inline\r\n    fn fetch_sub(inout self, rhs: Scalar[type]) -> Scalar[type]:\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        return __mlir_op.`pop.atomic.rmw`[\r\n            bin_op = __mlir_attr.`#pop<bin_op sub>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\r\n        ](value_addr.address, rhs.value)"
    },
    {
        "text": "    @always_inline\r\n    fn __isub__(inout self, rhs: Scalar[type]):\r\n\r\n        _ = self.fetch_sub(rhs)"
    },
    {
        "text": "    @always_inline\r\n    fn max(inout self, rhs: Scalar[type]):\r\n\r\n        constrained[\r\n            type.is_integral() or type.is_floating_point(),\r\n            \"the input type must be arithmetic\",\r\n        ]()\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        _ = __mlir_op.`pop.atomic.rmw`[\r\n            bin_op = __mlir_attr.`#pop<bin_op max>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\r\n        ](value_addr.address, rhs.value)"
    },
    {
        "text": "    @always_inline\r\n    fn min(inout self, rhs: Scalar[type]):\r\n\r\n\r\n        constrained[\r\n            type.is_integral() or type.is_floating_point(),\r\n            \"the input type must be arithmetic\",\r\n        ]()\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        _ = __mlir_op.`pop.atomic.rmw`[\r\n            bin_op = __mlir_attr.`#pop<bin_op min>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\r\n        ](value_addr.address, rhs.value)"
    },
    {
        "text": "fn setenv(name: String, value: String, overwrite: Bool = True) -> Bool:\r\n\r\n    alias os_is_supported = os_is_linux() or os_is_macos()\r\n    if not os_is_supported:\r\n        return False\r\n\r\n    var status = external_call[\"setenv\", Int32](\r\n        name._as_ptr(), value._as_ptr(), Int32(1 if overwrite else 0)\r\n    )\r\n    return status == 0"
    },
    {
        "text": "fn getenv(name: String, default: String = \"\") -> String:\r\n\r\n    alias os_is_supported = os_is_linux() or os_is_macos()\r\n\r\n    if not os_is_supported:\r\n        return default\r\n\r\n    var ptr = external_call[\"getenv\", DTypePointer[DType.int8]](name._as_ptr())\r\n    if not ptr:\r\n        return default\r\n    return String(StringRef(ptr))"
    },
    {
        "text": "fn stat[pathlike: os.PathLike](path: pathlike) raises -> stat_result:\r\n\r\n    return stat(path.__fspath__())\r\n"
    },
    {
        "text": "fn list(self) -> List[String]:\r\n\r\n\r\n        @parameter\r\n        if os_is_linux():\r\n            return self._list_linux()\r\n        else:\r\n            return self._list_macos()"
    },
    {
        "text": "    fn __del__(owned self):\r\n      \r\n        _ = external_call[\"closedir\", Int32](self._handle)"
    },
    {
        "text": "fn listdir(path: String = \"\") raises -> List[String]:\r\n\r\n\r\n    var dir = _DirHandle(path)\r\n    return dir.list()"
    },
    {
        "text": "fn listdir[pathlike: os.PathLike](path: pathlike) raises -> List[String]:\r\n\r\n    return listdir(path.__fspath__())"
    },
    {
        "text": "@always_inline(\"nodebug\")\r\nfn abort[result: Movable = NoneType]() -> result:\r\n\r\n\r\n    __mlir_op.`llvm.intr.trap`()\r\n\r\n    return AnyPointer[result]().take_value()"
    },
    {
        "text": "@always_inline(\"nodebug\")\r\nfn abort[\r\n    result: Movable = NoneType, *, stringable: Stringable\r\n](message: stringable) -> result:\r\n \r\n\r\n    @parameter\r\n    if not triple_is_nvidia_cuda():\r\n        print(message, flush=True)\r\n\r\n    return abort[result]()"
    },
    {
        "text": "    fn __init__(inout self, path: String) raises:\n\n        constrained[\n            not os_is_windows(), \"operation is only available on unix systems\"\n        ]()\n\n        if not isdir(path):\n            raise \"the directory '\" + path + \"' does not exist\"\n\n        self._handle = external_call[\"opendir\", Pointer[NoneType]](\n            path._as_ptr()\n        )\n\n        if not self._handle:\n            raise \"unable to open the directory '\" + path + \"'\""
    },
    {
        "text": "@always_inline\r\nfn _clock_gettime(clockid: Int) -> _CTimeSpec:\r\n  \r\n    var ts = _CTimeSpec()\r\n\r\n    # Call libc's clock_gettime.\r\n    _ = external_call[\"clock_gettime\", Int32](\r\n        Int32(clockid), Pointer.address_of(ts)\r\n    )\r\n\r\n    return ts"
    },
    {
        "text": "@always_inline\r\nfn _realtime_nanoseconds() -> Int:\r\n   \r\n    return _gettime_as_nsec_unix(_CLOCK_REALTIME)"
    },
    {
        "text": "@always_inline\r\nfn _monotonic_nanoseconds() -> Int:\r\n    \r\n\r\n    @parameter\r\n    if os_is_windows():\r\n        var ft = _FILETIME()\r\n        external_call[\"GetSystemTimePreciseAsFileTime\", NoneType](\r\n            Pointer.address_of(ft)\r\n        )\r\n\r\n        return ft.as_nanoseconds()\r\n    else:\r\n        return _gettime_as_nsec_unix(_CLOCK_MONOTONIC)"
    },
    {
        "text": "@always_inline\r\nfn _monotonic_raw_nanoseconds() -> Int:\r\n  \r\n\r\n    return _gettime_as_nsec_unix(_CLOCK_MONOTONIC_RAW)"
    },
    {
        "text": "@always_inline\r\nfn _process_cputime_nanoseconds() -> Int:\r\n   \r\n\r\n    return _gettime_as_nsec_unix(_CLOCK_PROCESS_CPUTIME_ID)"
    },
    {
        "text": "@always_inline\nfn now() -> Int:\n\n    return _monotonic_nanoseconds()"
    },
    {
        "text": "@always_inline\n@parameter\nfn time_function[func: fn () capturing -> None]() -> Int:\n\n\n    @parameter\n    if os_is_windows():\n        return _time_function_windows[func]()\n\n    var tic = now()\n    func()\n    var toc = now()\n    return toc - tic"
    },
    {
        "text": "fn sleep(sec: Int):\n\n\n    @parameter\n    if os_is_windows():\n        external_call[\"Sleep\", NoneType](sec * 1000)\n    else:\n        external_call[\"sleep\", NoneType](sec)"
    },
    {
        "text": "    @always_inline(\"nodebug\")\r\n    fn __lt__(self, rhs: Self) -> Bool:\r\n\r\n        return int(self) < int(rhs)"
    },
    {
        "text": "fn pow(base: Int, exp: Int = 2) -> Int:\r\n    return base ** exp"
    }
]