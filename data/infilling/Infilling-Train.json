[
    {
        "text": "<PRE>fn sig<SUF>-> Float64:\r\n    return 1 / (1 + exp(-x))<MID>moid(x: Float64) "
    },
    {
        "text": "<PRE>fn gradient_descent(<SUF>rning_rate: Float64, n_iter: Int=50, tolerance: Float64=1e-06) raises:\r\n    let np = Python.import_module('numpy')\r\n    var vector = start\r\n    for _ in range(n_iter):\r\n        let diff = -learning_rate * 2 * vector\r\n        if np.all(np.abs(diff) <= tolerance):\r\n            break\r\n        vector += diff\r\n    print(vector)<MID>start: Float64, lea"
    },
    {
        "text": "<PRE>fn m<SUF>, world!\")<MID>ain():\r\n    print(\"Hello"
    },
    {
        "text": "<PRE>fn euclidean_dist<SUF>\n    print(euclidean_distance)<MID>(x1: Int64, y1: Int64, x2: Int64, y2: Int64):\r\n    let x = x2 - x1\r\n    let y = y2 - y1\r\n    let euclidean_distance = sqrt(pow(x, 2) + pow(y,2))\r"
    },
    {
        "text": "<PRE>def mandelbrot_kernel(c: ComplexFloat64) -> Int:\r\n    z <SUF>z + c\r\n        if z.squared_norm() > 4:\r\n            return i\r\n    return MAX_ITERS<MID>= c\r\n    for i in range(MAX_ITERS):\r\n        z = z * "
    },
    {
        "text": "<PRE>def compute_mandelbrot() -> Tensor[float_type]:\n    # create a matrix. Each element of the matrix corresponds to a pixel\n    t = Tensor[float_ty<SUF>(max_x - min_x) / width\n    dy = (max_y - min_y) / height\n\n    y = min_y\n    for row in range(height):\n        x = min_x\n        for col in range(width):\n            t[Index(row, col)] = mandelbrot_kernel(ComplexFloat64(x, y))\n            x += dx\n        y += dy\n    return t<MID>pe](height, width)\n\n    dx = "
    },
    {
        "text": "<PRE>    fn is_https(self) -> Bool:\r\n        return bytes_equal(self.__s<SUF>rHttps)<MID>cheme, st"
    },
    {
        "text": "<PRE>    fn path_orig<SUF>       return self.__path_original<MID>inal(self) -> Bytes:\r\n "
    },
    {
        "text": "<PRE>    fn set_path(inout self, path: String<SUF>, self.__path_original)<MID>) -> Self:\r\n        self.__path = normalise_path(path._buffer"
    },
    {
        "text": "<PRE>    fn set_path_sbytes(inout self, path: Byte<SUF>\r\n        self.__path = normalise_path(path, self.__path_original)\r\n        return self<MID>s) -> Self:"
    },
    {
        "text": "<PRE>    fn path(self) -> String:\n        var processed_path = self.__path\n        if len(processed_path) == 0:\n            processed_path =<SUF>ath)\n<MID> strSlash\n        return String(processed_p"
    },
    {
        "text": "<PRE>    fn set_scheme(inout self, scheme: Strin<SUF>\r\n        return self\r\n\r<MID>g) -> Self:\r\n        self.__scheme = scheme._buffer"
    },
    {
        "text": "<PRE>    fn set_sche<SUF>turn self<MID>me_bytes(inout self, scheme: Bytes) -> Self:\r\n        self.__scheme = scheme\r\n        re"
    },
    {
        "text": "<PRE>    fn scheme(self) -> Bytes:\r\n        var processed_scheme = self.__scheme\r\n        if len(processed_scheme) == 0:\r\n            proce<SUF>_scheme\r<MID>ssed_scheme = strHttp\r\n        return processed"
    },
    {
        "text": "<PRE>    fn is<SUF>Https)<MID>_https(self) -> Bool:\r\n        return bytes_equal(self.__scheme, str"
    },
    {
        "text": "<PRE>    fn is_http(<SUF>lf.__scheme) == 0<MID>self) -> Bool:\r\n        return bytes_equal(self.__scheme, strHttp) or len(se"
    },
    {
        "text": "<PRE>@value\r\nstruct ErrorHandler:\r\n    fn Error(self) -> HTTPResponse:\r\n        return HTTPResponse(ResponseHeader(), String(\"TODO\").as_bytes())\r\n\r\n\r\nalias errNeedMore = Error(\"need more data: cannot<SUF> header name\")\r\nalias errSmallBuffer = Error(\"small read buffer. Increase ReadBufferSize\")<MID> find trailing lf\")\r\nalias errInvalidName = Error(\"invalid"
    },
    {
        "text": "<PRE>@value\nstruct HTTPResponse(Response):\n    <SUF>der_flush = False\n        self.stream_body = False\n        self.body_raw = body_bytes\n        self.skip_reading_writing_body = False\n        self.raddr = TCPAddr()\n        self.laddr = TCPAddr()<MID>var header: ResponseHeader\n    var stream_immediate_header_flush: Bool\n    var stream_body: Bool\n    var body_raw: Bytes\n    var skip_reading_writing_body: Bool\n    var raddr: TCPAddr\n    var laddr: TCPAddr\n\n    fn __init__(inout self, header: ResponseHeader, body_bytes: Bytes):\n        self.header = header\n        self.stream_immediate_hea"
    },
    {
        "text": "<PRE>    fn set_status_cod<SUF>code)\r\n        return self<MID>e(inout self, status_code: Int) -> Self:\r\n        _ = self.header.set_status_code(status_"
    },
    {
        "text": "<PRE>    fn status_code(self) -> Int:\r\n        return self.header.s<SUF>tus_code()<MID>ta"
    },
    {
        "text": "<PRE>    fn connection_close(sel<SUF>r.connection_close()<MID>f) -> Bool:\r\n        return self.heade"
    },
    {
        "text": "<PRE>fn OK(body: Bytes) -> HTTPResponse:\r\n    return HTTPResp<SUF>tring(\"Content-Type: text/plain\").as_bytes()\r\n        ),\r\n        body,\r\n    )<MID>onse(\r\n        ResponseHeader(\r\n            True, 200, String(\"OK\").as_bytes(), S"
    },
    {
        "text": "<PRE>fn OK(body: Bytes, content_type: String)<SUF>    )<MID> -> HTTPResponse:\r\n    return HTTPResponse(\r\n        ResponseHeader(True, 200, String(\"OK\").as_bytes(), content_type.as_bytes()), body\r\n"
    },
    {
        "text": "<PRE>@value\nstruct TCPAddr(Addr):\n    var ip: String\n    var port: Int\n    var zone: String  # IPv6 addressing zo<SUF>return join_host_port(self.ip, self.port)\n<MID>ne\n\n    fn __init__(inout self):\n        self.ip = String(\"127.0.0.1\")\n        self.port = 8000\n        self.zone = \"\"\n\n    fn __init__(inout self, ip: String, port: Int):\n        self.ip = ip\n        self.port = port\n        self.zone = \"\"\n\n    fn network(self) -> String:\n        return NetworkType.tcp.value\n\n    fn string(self) -> String:\n        if self.zone != \"\":\n            return join_host_port(String(self.ip) + \"%\" + self.zone, self.port)\n        "
    },
    {
        "text": "<PRE>fn join_host_port(host: String, port: String) -> String:\n    if host.find(\":\") != -1:  # must be IPv6 liter<SUF>rt\n    return host + \":\" + port<MID>al\n        return \"[\" + host + \"]:\" + po"
    },
    {
        "text": "<PRE>    fn write(self, data: String) raises -> Int:\r\n        var buffer: Str\r\n        with St<SUF>          raise Error(\"Failed to write to file descriptor \" + self.fd.__str__())\r\n\r\n            return write_count<MID>r(data) as buffer:\r\n            var write_count: c_ssize_t = external_call[\r\n                \"write\", c_ssize_t, c_int, char_pointer, c_size_t\r\n            ](self.fd, buffer.vector.data, data.__len__())\r\n\r\n            if write_count == -1:\r\n      "
    },
    {
        "text": "<PRE>@value\r\nstruct Printer(HTTPService):\r\n<SUF> raises -> HTTPResponse:\r\n        var body = req.body_raw\r\n        print(String(body))\r\n\r\n        return OK(body)<MID>    fn func(self, req: HTTPRequest)"
    },
    {
        "text": "<PRE>@value\r\nstruct Welcome(HTTPService):\r\n    fn func(self, req: HTTPRequest) ra<SUF>htbug_welcome.html\", \"r\") as f:\r\n            html = f.read()\r\n\r\n        return OK(html.as_bytes(), \"text/html\")<MID>ises -> HTTPResponse:\r\n        var html: String\r\n        with open(\"static/lig"
    },
    {
        "text": "<PRE>@value\nstru<SUF>= \"/\":\n            print(\"I'm on the index path!\")\n        if uri.path() == \"/first\":\n            print(\"I'm on /first!\")\n        elif uri.path() == \"/second\":\n            print(\"I'm on /second!\")\n        elif uri.path() == \"/echo\":\n            print(String(body))\n\n        return OK(body)<MID>ct ExampleRouter(HTTPService):\n    fn func(self, req: HTTPRequest) raises -> HTTPResponse:\n        var body = req.body_raw\n        var uri = req.uri()\n\n        if uri.path() ="
    },
    {
        "text": "<PRE>    @always_inline\n    fn __init__() -> Self:\n        # allocate a DTypePointer on stack that doesn't need to be freed.\n        var data = stack_allocat<SUF>th)\n        return Self {data: data}<MID>ion[width, T]()\n        memset_zero(data, wid"
    },
    {
        "text": "<PRE>    @always_i<SUF>        self.data.simd_store[_width](newVal)<MID>nline\n    fn accumulate[_width: Int](inout self, val: SIMD[T, _width]) -> None:\n \n        var newVal = self.data.simd_load[_width]() + val\n"
    },
    {
        "text": "<PRE>struct TensorSlice:<SUF>  self._shape = TensorShape(1)\r\n            raise Error(\"TensorSlice: rank greater than 3 not implemented.\")<MID>\r\n    var _data: BufferPtrFloat32\r\n    var _shape: TensorShape\r\n\r\n    fn __init__(inout self, t: TensorF32, layer: Int) raises:\r\n        var elements_per_layer = t.num_elements() // t.dim(0)\r\n        self._data = t.data().offset(layer * elements_per_layer)\r\n        if t.rank() == 2:\r\n            self._shape = TensorShape(t.dim(1))\r\n        elif t.rank() == 3:\r\n            self._shape = TensorShape(t.dim(1), t.dim(2))\r\n        else:\r\n            # Compiler complains if _shape not defined\r\n          "
    },
    {
        "text": "<PRE>    fn<SUF>> SIMD[DType.float32, nelts]:\r\n        return self._data.simd_load[nelts](idx)<MID> simd_load[nelts: Int](self, idx: Int) -"
    },
    {
        "text": "<PRE>fn read_val_int(inout buf: FileBuf) raises -> Int:\n    # DTypePointer[DType.ui8](buf.data)<SUF>tcast[DType.ui8]()\n    var data = buf.data.offset(buf.get_offset()).bitcast[DType.int32]()\n    var result = data.load(0)\n    buf.move_offset(4)\n    return result.to_int()\n<MID>.bi"
    },
    {
        "text": "<PRE>fn read_val_float32(inout buf: FileBuf) raises -> Float32:\r\n    # DTypePointer[DType.ui<SUF>r val = buf.data.offset(buf.get_offset()).bitcast[DType.float32]().load(0)\r\n    buf.move_offset(4)\r\n    return val<MID>8](buf.data).bitcast[DType.ui8]()\r\n    va"
    },
    {
        "text": "<PRE>fn read_val_str(inout buf: FileBuf, slen: Int) raises -> PointerString:\r\n    var str = PointerString.alloc(slen + 1)\r\n    for i in range(slen):\r\n        str.store(i, buf.data.lo<SUF>\n    return str<MID>ad(buf.get_offset()))\r\n        buf.move_offset(1)\r\n    str.store(slen, 0)\r\n\r"
    },
    {
        "text": "<PRE>fn partition(\n    inout array: PointerStrings, inout indices: DynamicVector[Int], low: Int, high: Int\n) -> Int:\n    var pivot = array[high]\n    var ii = low - 1\n    for jj in range(low, high):\n        if string_compare(pivot, array[jj]) ==<SUF>    var tmp_idx = indices[ii + 1]\n    array.store(ii + 1, array[high])\n    indices[ii + 1] = indices[high]\n    array.store(high, tmp)\n    indices[high] = tmp_idx\n\n    return ii + 1\n<MID> 1:\n            # If element smaller than pivot, swap\n            ii = ii + 1\n\n            var tmp = array[ii]\n            var tmp_idx = indices[ii]\n            array.store(ii, array[jj])\n            indices[ii] = indices[jj]\n            array.store(jj, tmp)\n            indices[jj] = tmp_idx\n\n    # Swap the pivot element\n    var tmp = array[ii + 1]\n"
    },
    {
        "text": "<PRE>fn quicksort(\n    inout array: PointerStrings, inout<SUF>: DynamicVector[Int], low: Int, high: Int\n):\n    if low < high:\n        var pi = partition(array, indices, low, high)\n        quicksort(array, indices, low, pi - 1)\n        quicksort(array, indices, pi + 1, high)<MID> indices"
    },
    {
        "text": "<PRE>    fn move_offset(inout self, size: Int) raises:\r\n        var new_offset = self.offset + size\r\n        if new_offset > self.size:\r\n            raise Error(\"Resu<SUF>g offset will be before the beginning of the FileBuf\")\r\n        self.offset = new_offset<MID>lting offset will be past the end of the FileBuf\")\r\n        if new_offset < 0:\r\n            raise Error(\"Resultin"
    },
    {
        "text": "<PRE>    fn bitcast_offset_f3<SUF>ret = self.data.offset(self.offset).bitcast[DType.float32]()\r\n        self.move_offset(size * sizeof[DType.float32]())\r\n        return ret<MID>2(inout self, size: Int) raises -> BufferPtrFloat32:\r\n        var "
    },
    {
        "text": "<PRE>    fn get_offset(self) raises -> Int:\n        if sel<SUF>size:\n            raise Error(\"Offset is past the end of the FileBuf\")\n        if self.offset < 0:\n            raise Error(\"Offset is before the beginning of the FileBuf\")\n        return self.offset\n<MID>f.offset > self."
    },
    {
        "text": "<PRE>struct Tokenizer:\n    var vocab: PointerStrings\n    var vocab_scores: BufferPtrFloat32\n    var max_token_length: Int\n    var vocab_size: Int\n    var sorted_vocab: PointerStrings\n    var sorted_indices: DynamicVector[Int]\n\n    fn __init__(inout self, vocab_size: Int, inout buf: FileBuf) raises -> None:\n        self.vocab_size = voc<SUF>PointerStrings.alloc(self.vocab_size)\n        self.sorted_vocab = PointerStrings.alloc(0)\n        self.sorted_indices = DynamicVector[Int]()\n\n        for i in range(0, self.vocab_size):\n            var score = read_val_float32(buf)\n            var slen = read_val_int(buf)\n            var token = read_val_str(buf, slen)\n            self.store_token(i, token, score)\n        return None<MID>ab_size\n        self.max_token_length = read_val_int(buf)\n        self.vocab_scores = BufferPtrFloat32.alloc(self.vocab_size)\n        self.vocab = "
    },
    {
        "text": "<PRE>    fn<SUF>for i in range(0, self.vocab_size):\n            self.vocab[i].free()\n        self.vocab.free()\n        self.vocab_scores.free()\n        self.sorted_vocab.free()\n<MID> __del__(owned self):\n        "
    },
    {
        "text": "<PRE>fn sort(inout self) -> None:\r\n        if len(self.sorted_indices) < self.vocab_size:\r\n            self.sorted_i<SUF>vocab_size)\r\n            for ii in range(self.vocab_size):\r\n                self.sorted_vocab.store(ii, self.vocab[ii])\r\n                self.sorted_indices.push_back(ii)\r\n\r\n        var n = self.vocab_size\r\n        quicksort(self.sorted_vocab, self.sorted_indices, 0, n - 1)\r\n        return None<MID>ndices = DynamicVector[Int](capacity=self.vocab_size)\r\n            self.sorted_vocab = PointerStrings.alloc(self."
    },
    {
        "text": "<PRE>\r\n    fn find(inout self, token_o: PointerString) -> Int:\r\n        var token = wrap(token_o)\r\n        var n = self.vocab_size\r\n        if len(self.sorted_indices) < n:\r\n            self.sort()\r\n        var left = 0\r\n        var right = n - 1\r\n        while left <= right:\r\n            var mid = left + (right - left) // 2\r\n            var comparison = string_compare(self.sorted_vocab[mid], token)\r\n            if comparison == 0:\r<SUF>          else:\r\n                right = mid - 1\r\n        return -1<MID>\n                return self.sorted_indices[mid]\r\n            if comparison < 0:\r\n                left = mid + 1\r\n  "
    },
    {
        "text": "<PRE>@always<SUF>a.dim(0)\n\n    @parameter\n    fn _acc[_nelts: Int](j: Int):\n        a.simd_store[_nelts](j, a.simd_load[_nelts](j) + b.simd_load[_nelts](j))\n\n    vectorize[_acc, nelts](size)<MID>_inline\nfn accum(inout a: TensorF32, b: TensorF32) -> None:\n    var size = "
    },
    {
        "text": "<PRE>@always_inline\r\n<SUF>: TensorF32) -> None:\r\n    softmax(x, 0, x.dim(0))<MID>fn softmax(inout x"
    },
    {
        "text": "<PRE>@always_inline\nfn rope_rotation_llama(\n    inout state: RunState,\n    freq_cis_real_row: TensorSlice,\n    freq_cis_imag_row: TensorSlice,<SUF>g,\n) -> None:\n    # stories model, llama2\n    var head_size = config.head_size<MID>\n    config: Confi"
    },
    {
        "text": "<PRE>    @parameter\n    fn head_loop(i: Int):\n\n        for j in range(0, config.head_size, 2):\n            var fcr = freq_cis_real_row[j // 2]\n            var fci = freq_cis_imag_row[j // 2]\n            var q0 = state.q[i * head_size + j]\n            var q1 = state.q[i * head_size + j + 1]\n            state.q[i * head_size + j] = q0 * fcr - q1 * fci\n            state.q[i * head_size + j + 1] = q0 * fci + q1 * fcr\n            if i < config.n_kv_heads:\n                var k0 = state.k[i * head_size + j]\n                var k1<SUF> fcr<MID> = state.k[i * head_size + j + 1]\n                state.k[i * head_size + j] = k0 * fcr - k1 * fci\n                state.k[i * head_size + j + 1] = k0 * fci + k1 *"
    },
    {
        "text": "<PRE>fn argmax(v: TensorF32) -> Int:\n  \n    var max_i: <SUF>: Float32 = v[0]\n    for i in range(v.dim(0)):\n        if v[i] > max_p:\n            max_i = i\n            max_p = v[i]\n    return max_i\n<MID>Int = 0\n    var max_p"
    },
    {
        "text": "<PRE>fn sample(probabilities: TensorF32) -> Int:\n    var n = probabilities.dim(0)\n    # Sample index from probabilities, they must sum to 1\n    # get ra<SUF> = 0.0\n    for i in range(n):\n        cdf += probabilities[i]\n        if r[0] < cdf:\n            return i\n    return n - 1  # In case of rounding errors\n<MID>ndom value within (min, max) float32 range\n    var r = rand[DType.float32](1)\n    var cdf: Float32"
    },
    {
        "text": "<PRE>from time import now\n\nfrom algorithm import sum\nfrom benchmark import Unit, benchmark, keep\nfrom buffer import Buffer\nfrom tensor import Tensor\nfrom python import Python\nfrom tensor import rand\n\nalias size_small: Int = 1 << 21\nalias size_large: Int = 1 << 27\nalias ty<SUF>: StringLiteral,\n](array: Tensor[type]) raises:\n    @parameter\n    fn runner():\n        var result = func[size](array)\n        keep(result)\n\n    var ms = benchmark.run[runner](max_runtime_secs=0.5).mean(Unit.ms)\n    pretty_print(name, size, ms)\n\n\nfn main() raises:\n    var small_array = rand[type](size_small)\n    var large_array = rand[type](size_large)\n\n    bench[naive_reduce_sum, size_small, \"naive\"](small_array)\n    bench[naive_reduce_sum, size_large, \"naive\"](large_array)\n\n    bench[stdlib_reduce_sum, size_small, \"stdlib\"](small_array)\n    bench[stdlib_reduce_sum, size_large, \"stdlib\"](large_array)<MID>pe = DType.float32\n\n\nfn stdlib_reduce_sum[size: Int](array: Tensor[type]) -> Float32:\n    var my_sum = sum(array._to_buffer())\n    return my_sum\n\n\nfn bench[\n    func: fn[size: Int] (array: Tensor[type]) -> Float32,\n    size: Int,\n    name"
    },
    {
        "text": "<PRE>fn pretty_print(name: StringLiteral, elements: Int, <SUF>ltins\")\r\n    _ = py.print(\r\n        py.str(\"{:<16} {:>11,} {:>8.2f}ms\").format(\r\n            String(name) + \" elements:\", elements, time\r\n        )\r\n    )<MID>time: Float64) raises:\r\n    var py = Python.import_module(\"bui"
    },
    {
        "text": "<PRE>\nfn naive_reduce_sum[size: Int](array: Tensor[type]) -> Float32:\n    var A = array\n    var my_sum = array[0]\n    var c: Float32 = 0.0\n    for i <SUF>m) - y\n        my_sum = t\n    return my_sum<MID>in range(array.dim(0)):\n        var y = array[i] - c\n        var t = my_sum + y\n        c = (t - my_su"
    },
    {
        "text": "<PRE>from sys.info import *\nfrom sys.info import _current_cpu, _current_target, _triple_attr\n\n\ndef main():\n    var os = \"\"\n    if os_is_linux():\n        os = \"linux\"\n    elif os_is_macos():\n        os = \"macOS\"\n    else:\n        os = \"windows\"\n    var cpu = String(_current_cpu())\n    var arch = String(_triple_attr())\n\n    print(\"System information: \")\n    print(\"    OS             : \", os)\n    print(\"    CPU     <SUF>h)\n\n  \n<MID>       : \", cpu)\n    print(\"    Arch           : \", arc"
    },
    {
        "text": "<PRE>@always_inline(\"nodebug\")\r\nfn _digits[type: DType]()<SUF>turn 8\r\n\r\n    @parameter\r\n    if type == DType.float32:\r\n        return 24\r\n\r\n    @parameter\r\n    if type == DType.float64:\r\n        return 53\r\n    # Unreachable.\r\n    return -1<MID> -> Int:\r\n\r\n    alias mlir_type = __mlir_type[`!pop.scalar<`, type.value, `>`]\r\n\r\n    @parameter\r\n    if type == DType.bool:\r\n        return 1\r\n\r\n    @parameter\r\n    if type.is_integral():\r\n        var bitwidth = bitwidthof[mlir_type]()\r\n        return bitwidth - 1 if type.is_signed() else bitwidth\r\n\r\n    @parameter\r\n    if type == DType.float16:\r\n        return 11\r\n\r\n    @parameter\r\n    if type == DType.bfloat16:\r\n        re"
    },
    {
        "text": "<PRE>@always_inline\r\nfn _fp_bitcast_to_integer[type: DType](value: Scalar[type]) -> Int:\r\n\r\n    alias integer_type = _integra<SUF>e, 1](value))\r\n<MID>l_type_of[type]()\r\n    return int(bitcast[integer_typ"
    },
    {
        "text": "<PRE>@always_i<SUF>Scalar[type]:\r\n\r\n    alias integer_type = _integral_type_of[type]()\r\n    var int_val = SIMD[integer_type, 1](value)\r\n    return bitcast[type, 1](int_val)<MID>nline\r\nfn _fp_bitcast_from_integer[type: DType](value: Int) -> "
    },
    {
        "text": "<PRE> @staticmethod\r\n    @always_inline(\"nodebug\")\r\n    fn max_exponent(<SUF>rn 128\r\n\r\n        debug_assert(type == DType.float64, \"must be float64\")\r\n        return 1024\r\n<MID>) -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n\r\n        @parameter\r\n        if type == DType.float16:\r\n            return 16\r\n        elif type == DType.float32 or type == DType.bfloat16:\r\n            retu"
    },
    {
        "text": "<PRE> @staticmethod\r\n    @always_inline(\"nodebug\")\r\n    fn exponent_width() -> Int:\r\n        \r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n\r\n        @parameter\r\n<SUF>16:\r\n            return 5\r\n        elif type == DType.float32 or type == DType.bfloat16:\r\n            return 8\r\n\r\n        debug_assert(type == DType.float64, \"must be float64\")\r\n        return 11\r\n<MID>        if type == DType.float"
    },
    {
        "text": "<PRE>    @staticmethod\r\n    @always_inline\r\n    fn mantissa_mask() -> Int:\r\n\r\n    <SUF>\n        return (1 << Self.mantissa_width()) - 1<MID>    constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r"
    },
    {
        "text": "<PRE>    @staticmethod\r\n   <SUF>      ]()\r\n        return Self.max_exponent() - 1<MID> @always_inline\r\n    fn exponent_bias() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n  "
    },
    {
        "text": "<PRE>    @staticmethod\r\n    @always_inline\r\n<SUF>type\",\r\n        ]()\r\n        return 1 << (Self.exponent_width() + Self.mantissa_width())<MID>    fn sign_mask() -> Int:\r\n\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point "
    },
    {
        "text": "<PRE>    @staticmethod\r\n    @always_inline\r\n    fn exponent_mantissa_mask() -> Int:\r\n\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        return Self.<SUF>ntissa_mask()<MID>exponent_mask() + Self.ma"
    },
    {
        "text": "<PRE>    @staticmethod\r\n    @alw<SUF>() -> Int:\r\n\r\n        constrained[\r\n            type.is_floating_point(),\r\n            \"dtype must be a floating point type\",\r\n        ]()\r\n        var mantissa_width_val = Self.mantissa_width()\r\n        return (1 << Self.exponent_width() - 1) << mantissa_width_val + (\r\n            1 << (mantissa_width_val - 1)\r\n        )<MID>ays_inline\r\n    fn quiet_nan_mask"
    },
    {
        "text": "<PRE>    @staticmethod\r\n    @always_inline\r\n    fn bitcast_to_<SUF>](value)<MID>integer(value: Scalar[type]) -> Int:\r\n\r\n        return _fp_bitcast_to_integer[type"
    },
    {
        "text": "<PRE>    @staticmethod\r\n    @always_inline\r\n    fn bitcast_fro<SUF>ue)<MID>m_integer(value: Int) -> Scalar[type]:\r\n\r\n        return _fp_bitcast_from_integer[type](val"
    },
    {
        "text": "<PRE>    @staticmeth<SUF>]) -> Bool:\r\n\r\n\r\n        return (Self.bitcast_to_integer(value) & Self.sign_mask()) != 0<MID>od\r\n    @always_inline\r\n    fn get_sign(value: Scalar[type"
    },
    {
        "text": "<PRE>    @staticmethod\r\n    @always_inline\r\n    fn set_sign(value: Scalar[<SUF>(bits)<MID>type], sign: Bool) -> Scalar[type]:\r\n\r\n        var bits = Self.bitcast_to_integer(value)\r\n        var sign_bits = Self.sign_mask()\r\n        bits &= ~sign_bits\r\n        if sign:\r\n            bits |= sign_bits\r\n        return Self.bitcast_from_integer"
    },
    {
        "text": "<PRE>    @staticmethod\r\n    @always_inline\r\n    fn get_exponent_without_bias(value: <SUF>calar[type]) -> Int:\r\n\r\n\r\n        return Self.get_exponent(value) - Self.exponent_bias()<MID>S"
    },
    {
        "text": "<PRE>    @staticmethod\n    @always_inline\n    fn set_exponent(value: Scalar[type], exponent: Int) -> Scalar[type]:\n\n        var bits = Sel<SUF>.exponent_mask()\n        bits |= (exponent << Self.mantissa_width()) & Self.exponent_mask()\n        return Self.bitcast_from_integer(bits)<MID>f.bitcast_to_integer(value)\n        bits &= ~Self"
    },
    {
        "text": "<PRE>@always_inline(\"nodebug\")\r\nfn isinf[\r\n    type: DType, simd_width: Int\r\n](val: SIMD[type, simd_width]) -> SIMD[DType.bool, simd_width]:\r\n\r\n\r\n    @parameter\r\n    if not type.i<SUF>trinsic[\"llvm.is.fpclass\", SIMD[DType.bool, simd_width]](\r\n        val.value, (negative_infinity_test | positive_infinity_test).value\r\n    )<MID>s_floating_point():\r\n        return False\r\n\r\n    alias negative_infinity_test: UInt32 = 0x0004\r\n    alias positive_infinity_test: UInt32 = 0x0200\r\n    return llvm_in"
    },
    {
        "text": "<PRE>@always_inline<SUF>lass\", SIMD[DType.bool, simd_width]](\r\n        val.value, (signaling_nan_test | quiet_nan_test).value\r\n    )\r\n<MID>(\"nodebug\")\r\nfn isnan[\r\n    type: DType, simd_width: Int\r\n](val: SIMD[type, simd_width]) -> SIMD[DType.bool, simd_width]:\r\n\r\n\r\n    @parameter\r\n    if not type.is_floating_point():\r\n        return False\r\n\r\n    @parameter\r\n    if type == DType.bfloat16:\r\n        alias int_dtype = _integral_type_of[type]()\r\n        var int_val = bitcast[int_dtype, simd_width](val)\r\n        return int_val & SIMD[int_dtype, simd_width](0x7FFF) > SIMD[\r\n            int_dtype, simd_width\r\n        ](0x7F80)\r\n\r\n    alias signaling_nan_test: UInt32 = 0x0001\r\n    alias quiet_nan_test: UInt32 = 0x0002\r\n    return llvm_intrinsic[\"llvm.is.fpc"
    },
    {
        "text": "<PRE>@always_inline\nfn _reduce_and<SUF>Bool) -> Bool:\n\n    return a and b<MID>_fn(a: Bool, b: "
    },
    {
        "text": "<PRE>@always_inline\r\nfn _int_t<SUF>\r\n\r\n\r\n    var c = StaticTuple[Int, size]()\r\n\r\n    @always_inline\r\n    @parameter\r\n    fn do_apply[idx: Int]():\r\n        var a_elem: Int = a.__getitem__[idx]()\r\n        var b_elem: Int = b.__getitem__[idx]()\r\n        c.__setitem__[idx](binary_fn(a_elem, b_elem))\r\n\r\n    unroll[do_apply, size]()\r\n\r\n    return c<MID>uple_binary_apply[\r\n    size: Int,\r\n    binary_fn: fn (Int, Int) -> Int,\r\n](a: StaticTuple[Int, size], b: StaticTuple[Int, size]) -> StaticTuple[\r\n    Int, size\r\n]:"
    },
    {
        "text": "<PRE>@always_inline\r\nfn _int_tuple_compare[\r\n    size: Int,\r\n    comp_fn: fn (Int, Int) -> Bool,\r\n](a: StaticTuple[Int, size], b: StaticTuple[Int, size]) -> StaticTup<SUF>ze]()\r\n\r\n    @always_inline\r\n    @parameter\r\n    fn do_compare[idx: Int]():\r\n        var a_elem: Int = a.__getitem__[idx]()\r\n        var b_elem: Int = b.__getitem__[idx]()\r\n        c.__setitem__[idx](comp_fn(a_elem, b_elem).value)\r\n\r\n    unroll[do_compare, size]()\r\n\r\n    return c\r\n<MID>le[\r\n    mlir_bool,\r\n    size,\r\n]:\r\n\r\n\r\n    var c = StaticTuple[mlir_bool, si"
    },
    {
        "text": "<PRE> @always_inline\n    fn __init__() <SUF>  return 0\n<MID>-> Self:\n\n      "
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn __init__(value: __mlir_type.index) -> Self:\r\n\r\n        constrained[size == 1]()\r\n<SUF>return Int(value)<MID>        "
    },
    {
        "text": "<PRE> @always_inline\r\n    fn __init__(elems: Tuple[Int, Int]) -> Self:\r\n\r\n\r\n        var num_elements = len(elems)\r\n\r\n        debug_assert(\r\n            size == num_elements,\r\n          <SUF>s\",\r\n        )\r\n\r\n        var tup = Self()\r\n\r\n        @parameter\r\n        fn fill[idx: Int]():\r\n            tup[idx] = elems.get[idx, Int]()\r\n\r\n        unroll[fill, 2]()\r\n\r\n        return tup<MID>  \"[StaticIntTuple] mismatch in the number of element"
    },
    {
        "text": "<PRE>@always_inline\r\n    fn __init__(elems: Tuple[Int, Int, Int, Int]) -> Self:\r\n\r\n\r\n    <SUF> num_elements = len(elems)\r\n\r\n        debug_assert(\r\n            size == num_elements,\r\n            \"[StaticIntTuple] mismatch in the number of elements\",\r\n        )\r\n\r\n        var tup = Self()\r\n\r\n        @parameter\r\n        fn fill[idx: Int]():\r\n            tup[idx] = elems.get[idx, Int]()\r\n\r\n        unroll[fill, 4]()\r\n\r\n        return tup\r\n<MID>    var"
    },
    {
        "text": "<PRE>@alw<SUF>(y), int(z))<MID>ays_inline\nfn Index[\n    T0: Intable, T1: Intable, T2: Intable\n](x: T0, y: T1, z: T2) -> StaticIntTuple[3]:\n\n    return StaticIntTuple[3](int(x), int"
    },
    {
        "text": "<PRE>@always_inline\nfn Index[\n    T0: Intable, T1: Intable, T2: Intable, T3: Intable\n](x: T0, y: T1,<SUF> -> StaticIntTuple[4]:\n\n    return StaticIntTuple[4](int(x), int(y), int(z), int(w))<MID> z: T2, w: T3)"
    },
    {
        "text": "<PRE>@always_inline\r\nfn Index[\r\n    T0: Intable, T1: Intable, T2: Intable, T3: Intable, T4: Int<SUF>, int(w), int(v))<MID>able\r\n](x: T0, y: T1, z: T2, w: T3, v: T4) -> StaticIntTuple[5]:\r\n\r\n    return StaticIntTuple[5](int(x), int(y), int(z)"
    },
    {
        "text": "<PRE>@always_inline\r\nfn now() -> Int:\r\n<SUF>\n<MID>\r\n    return _monotonic_nanoseconds()\r"
    },
    {
        "text": "<PRE>@always_inline\r\n@parameter\r\nfn time_function[func: fn () capturing -> None]() -> Int:\r\n\r\n\r\n    @pa<SUF> tic<MID>rameter\r\n    if os_is_windows():\r\n        return _time_function_windows[func]()\r\n\r\n    var tic = now()\r\n    func()\r\n    var toc = now()\r\n    return toc -"
    },
    {
        "text": "<PRE>fn sleep(sec: Flo<SUF>\n    var rem = Pointer[_CTimeSpec].get_null()\r\n    _ = external_call[\"nanosleep\", Int32](req, rem)<MID>at64):\r\n\r\n    alias NANOSECONDS_IN_SECOND = 1_000_000_000\r\n    var total_secs = _floor(sec)\r\n    var tv_spec = _CTimeSpec(\r\n        int(total_secs.cast[DType.index]()),\r\n        int((sec - total_secs) * NANOSECONDS_IN_SECOND),\r\n    )\r\n    var req = Pointer[_CTimeSpec].address_of(tv_spec)\r"
    },
    {
        "text": "<PRE>fn sleep(sec: Int):\r\n\r\n\r\n    @parameter\r\n   <SUF>\"sleep\", NoneType](sec)<MID> if os_is_windows():\r\n        # In Windows the argument is in milliseconds.\r\n        external_call[\"Sleep\", NoneType](sec * 1000)\r\n    else:\r\n        external_call["
    },
    {
        "text": "<PRE>fn b64encode(str: String) -> String:\n\n    alias lookup = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123<SUF>   var si_1 = s(i + 1)\n        var si_2 = s(i + 2)\n        out.append(b64chars.load(si // 4))\n        out.append(b64chars.load(((si * 16) % 64) + si_1 // 16))\n        out.append(b64chars.load(((si_1 * 4) % 64) + si_2 // 64))\n        out.append(b64chars.load(si_2 % 64))\n\n    var i = end\n    if i < length:\n        var si = s(i)\n        out.append(b64chars.load(si // 4))\n        if i == length - 1:\n            out.append(b64chars.load((si * 16) % 64))\n            out.append(ord(\"=\"))\n        elif i == length - 2:\n            var si_1 = s(i + 1)\n            out.append(b64chars.load(((si * 16) % 64) + si_1 // 16))\n            out.append(b64chars.load((si_1 * 4) % 64))\n        out.append(ord(\"=\"))\n    out.append(0)\n    return String(out ^)<MID>456789+/\"\n    var b64chars = lookup.data()\n\n    var length = len(str)\n    var out = List[Int8](capacity=length + 1)\n\n    @parameter\n    @always_inline\n    fn s(idx: Int) -> Int:\n        return int(str._buffer[idx])\n\n    var end = length - (length % 3)\n    for i in range(0, end, 3):\n        var si = s(i)\n     "
    },
    {
        "text": "<PRE>@value\nstruct _DictKeyIter[\n    K: KeyElement,\n    V: CollectionElement,\n    dict_mutability: __mlir_type.`i1`,\n    dict_lifetime: AnyLifetime[dict_mutability].type,\n]:\n\n\n    alias imm_dict_lifetime = __mlir_attr[\n        `#lit.lifetime.mutcast<`, dict_lifetime, `> : !lit.lifetime<1>`\n    ]\n    alias ref_type = Reference[K, __mlir_attr.`0: i1`, Self.imm_dict_lifetime]\n\n    var iter: <SUF>(\n            Reference(entry_ref[].key).value\n        )\n        var key_ptr = AnyPointer[K] {\n            value: __mlir_op.`pop.pointer.bitcast`[\n                _type = AnyPointer[K].pointer_type\n            ](mlir_ptr)\n        }\n        return __mlir_op.`lit.ref.from_pointer`[\n            _type = Self.ref_type.mlir_ref_type\n        ](key_ptr.value)\n\n    fn __len__(self) -> Int:\n        return self.iter.__len__()<MID>_DictEntryIter[K, V, dict_mutability, dict_lifetime]\n\n    fn __iter__(self) -> Self:\n        return self\n\n    fn __next__(inout self) -> Self.ref_type:\n        var entry_ref = self.iter.__next__()\n        var mlir_ptr = __mlir_op.`lit.ref.to_pointer`"
    },
    {
        "text": "<PRE>@value\nstruct _DictValueIter[\n    K: KeyElement,\n    V: CollectionElement,\n    <SUF>eturn self\n\n    fn __next__(inout self) -> Self.ref_type:\n        var entry_ref = self.iter.__next__()\n        var mlir_ptr = __mlir_op.`lit.ref.to_pointer`(\n            Reference(entry_ref[].value).value\n        )\n        var value_ptr = AnyPointer[V] {\n            value: __mlir_op.`pop.pointer.bitcast`[\n                _type = AnyPointer[V].pointer_type\n            ](mlir_ptr)\n        }\n        return __mlir_op.`lit.ref.from_pointer`[\n            _type = Self.ref_type.mlir_ref_type\n        ](value_ptr.value)\n\n    fn __len__(self) -> Int:\n        return self.iter.__len__()<MID>dict_mutability: __mlir_type.`i1`,\n    dict_lifetime: AnyLifetime[dict_mutability].type,\n]:\n\n\n    alias ref_type = Reference[V, dict_mutability, dict_lifetime]\n\n    var iter: _DictEntryIter[K, V, dict_mutability, dict_lifetime]\n\n    fn __iter__(self) -> Self:\n        r"
    },
    {
        "text": "<PRE>@value\nstruct DictEntry[K: KeyElement, V: CollectionElement](CollectionElement):\n\n    var hash: Int\n    var key: K \n    var value: V\n  \n\n    fn __init__(inout self, own<SUF>elf.key = key ^\n        self.value = value ^\n<MID>ed key: K, owned value: V):\n        self.hash = hash(key)\n        s"
    },
    {
        "text": "<PRE>    fn __init__(inout self, reserved: Int):\n        if reserved <= 128:\n            var data = DTypePointer[DType.int8].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.da<SUF>data = data.bitcast[DType.invalid]()\n        else:\n            var data = DTypePointer[DType.int64].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()<MID>ta = data.bitcast[DType.invalid]()\n        elif reserved <= 2**16 - 2:\n            var data = DTypePointer[DType.int16].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self.data = data.bitcast[DType.invalid]()\n        elif reserved <= 2**32 - 2:\n            var data = DTypePointer[DType.int32].alloc(reserved)\n            for i in range(reserved):\n                data[i] = _EMPTY\n            self."
    },
    {
        "text": "<PRE>    fn copy(self, reserved: Int) -> Self:\n        var index = Self(reserved)\n        if reserved <= 128:\n            var data = self.data.bitcast[DType.int8]()\n            var new_data = index.data.bitcast[DType.int8]()\n            memcpy(new_data, data, reserved)\n        elif reserved <= 2**16 - 2:\n            var data = self.data.bitcast[DType.int16]()\n            var new_data = index.data.bitcast[DType.int16]()\n            memcpy(new_data, data, reserved)\n        elif reserved <= 2*<SUF>ar new_data = index.data.bitcast[DType.int64]()\n            memcpy(new_data, data, reserved)\n        return index ^<MID>*32 - 2:\n            var data = self.data.bitcast[DType.int32]()\n            var new_data = index.data.bitcast[DType.int32]()\n            memcpy(new_data, data, reserved)\n        else:\n            var data = self.data.bitcast[DType.int64]()\n            v"
    },
    {
        "text": "<PRE>    fn get_index(self, reserved: Int, slot: Int) -> Int:\n        if reserved <= 128:\n            var data<SUF>        return data.load(slot % reserved).to_int()\n        else:\n            var data = self.data.bitcast[DType.int64]()\n            return data.load(slot % reserved).to_int()<MID> = self.data.bitcast[DType.int8]()\n            return data.load(slot % reserved).to_int()\n        elif reserved <= 2**16 - 2:\n            var data = self.data.bitcast[DType.int16]()\n            return data.load(slot % reserved).to_int()\n        elif reserved <= 2**32 - 2:\n            var data = self.data.bitcast[DType.int32]()\n    "
    },
    {
        "text": "<PRE>    fn set_index(inout self, reserved: Int, slot: Int, value: Int):\r\n        if reserved <= 128:\r\n            var data = self.data.bitcast[DType.int8]()\r\n            return data.store(slot % reserved, value)\r\n        elif reserved <= 2**16 - 2:\r\n            var data = self.data.bitcast[DType.int16]()\r\n            return data.store(slot % reserved, value)\r\n        elif reserved <= 2**32 - 2:\r\n            var data = self.d<SUF>st[DType.int64]()\r\n            return data.store(slot % reserved, value)<MID>ata.bitcast[DType.int32]()\r\n            return data.store(slot % reserved, value)\r\n        else:\r\n            var data = self.data.bitca"
    },
    {
        "text": "<PRE>var<SUF>size: Int<MID> "
    },
    {
        "text": "<PRE>var _n_ent<SUF>: Int<MID>ries"
    },
    {
        "text": "<PRE>var<SUF>nt<MID> _reserved: I"
    },
    {
        "text": "<PRE>  <SUF>   self._n_entries = 0\n        self._reserved = 8\n        self._index = _DictIndex(self._reserved)\n        self._entries = Self._new_entries(self._reserved)<MID>  fn __init__(inout self):\n\n        self.size = 0\n     "
    },
    {
        "text": "<PRE>    fn __init__(inout self, existing: Self):\n\n        self.size = exist<SUF> self._entries = existing._entries<MID>ing.size\n        self._n_entries = existing._n_entries\n        self._reserved = existing._reserved\n        self._index = existing._index.copy(existing._reserved)\n       "
    },
    {
        "text": "<PRE>    fn __copyinit__(inout self, existing: Self):\n\n        self.size = existing.size\n        self._n_entries = existing._n_entries\n        self._reserved = existing._reserved\n        self._index = existing._<SUF>tries = existing._entries<MID>index.copy(existing._reserved)\n        self._en"
    },
    {
        "text": "<PRE>    fn __moveinit__(inout self, owned existing: Self):\n\n        self.size = existing.size\n    <SUF>ed = existing._reserved\n        self._index = existing._index ^\n        self._entries = existing._entries ^<MID>    self._n_entries = existing._n_entries\n        self._reserv"
    },
    {
        "text": "<PRE>    fn __getitem__(s<SUF>ue.value()\n        raise \"KeyError\"<MID>elf, key: K) raises -> V:\n\n        var value = self.find(key)\n        if value:\n            return val"
    },
    {
        "text": "<PRE> <SUF>        self._insert(key, value)<MID>   fn __setitem__(inout self, key: K, value: V):\r\n\r\n"
    },
    {
        "text": "<PRE>    fn __contains__(self, key<SUF>ey).__bool__()<MID>: K) -> Bool:\n\n        return self.find(k"
    },
    {
        "text": "<PRE>    fn __len__(self) -> Int:\r\n       \r\n    <SUF>ze<MID>    return self.si"
    },
    {
        "text": "<PRE>    fn find(self, key: K) -> Optional[V]:\r<SUF>        var found: Bool\r\n        var slot: Int\r\n        var index: Int\r\n        found, slot, index = self._find_index(hash, key)\r\n        if found:\r\n            var ev = self._entries.__get_ref(index)[]\r\n            debug_assert(ev.__bool__(), \"entry in index must be full\")\r\n            return ev.value().value\r\n        return None<MID>\n \r\n        var hash = hash(key)\r\n"
    },
    {
        "text": "<PRE>    fn p<SUF>x] = None\r\n            self.size -= 1\r\n            debug_assert(entry.__bool__(), \"entry in index must be full\")\r\n            return entry.value().value\r\n        elif default:\r\n            return default.value()\r\n        raise \"KeyError\"<MID>op(inout self, key: K, owned default: Optional[V] = None) raises -> V:\r\n \r\n        var hash = hash(key)\r\n        var found: Bool\r\n        var slot: Int\r\n        var index: Int\r\n        found, slot, index = self._find_index(hash, key)\r\n        if found:\r\n            self._set_index(slot, Self.REMOVED)\r\n            var entry = self._entries.__get_ref(index)[]\r\n            self._entries[inde"
    },
    {
        "text": "<PRE>    fn __iter__[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _DictK<SUF>       return _DictKeyIter(\r\n            _DictEntryIter[K, V, mutability, self_life](0, 0, Reference(self))\r\n        )<MID>eyIter[K, V, mutability, self_life]:\r\n\r\n "
    },
    {
        "text": "<PRE>    fn keys[\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutabil<SUF>) -> _DictKeyIter[K, V, mutability, self_life]:\n\n        return Self.__iter__(self)<MID>ity].type\n    ](\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\n    "
    },
    {
        "text": "<PRE>    fn values[\r\n        mutability: __mlir_t<SUF>\n    ](\r\n        self: Reference[Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _DictValueIter[K, V, mutability, self_life]:\r\n\r\n        return _DictValueIter(\r\n            _DictEntryIter[K, V, mutability, self_life](0, 0, Reference(self))\r\n        )<MID>ype.`i1`, self_life: AnyLifetime[mutability].type\r"
    },
    {
        "text": "<PRE>    fn items[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Reference[Self, mutability, self_life]<SUF>rence(self)\r\n        )<MID>.mlir_ref_type,\r\n    ) -> _DictEntryIter[K, V, mutability, self_life]:\r\n\r\n        return _DictEntryIter[K, V, mutability, self_life](\r\n            0, 0, Refe"
    },
    {
        "text": "<PRE>    @staticmethod\r\n    fn _new_entries(reserved: Int) -> List[Optional[DictEntry[K, V]]]:\r\n       <SUF>V]]](capacity=reserved)\r\n        for i in range(reserved):\r\n            entries.append(None)\r\n        return entries<MID> var entries = List[Optional[DictEntry[K, "
    },
    {
        "text": "<PRE>    fn _insert(inout self, owned key: K, owned value: V):\r\n        self._insert(DictEntry[<SUF>)<MID>K, V](key ^, value ^)"
    },
    {
        "text": "<PRE>    fn _insert(inout self, owned entry: DictEntry[K, V]):\r\n        self._maybe_resize()\r\n        var found: Bool\r\n        var slot: Int<SUF>ex] = entry ^\r\n        if not found:\r\n            self._set_index(slot, index)\r\n            self.size += 1\r\n            self._n_entries += 1<MID>\r\n        var index: Int\r\n        found, slot, index = self._find_index(entry.hash, entry.key)\r\n\r\n        self._entries[ind"
    },
    {
        "text": "<PRE>    fn _get_index(self, slot<SUF>t) -> Int:\r\n        return self._index.get_index(self._reserved, slot)<MID>: In"
    },
    {
        "text": "<PRE>    fn _se<SUF>inout self, slot: Int, index: Int):\n        return self._index.set_index(self._reserved, slot, index)<MID>t_index("
    },
    {
        "text": "<PRE>    fn _next_index_slot(self, inout slot: Int, inout perturb: Int):\r\n        alias PERTURB_SHIFT = 5\r\n        perturb >>= PERTURB_SHIFT\r\n<SUF>1) % self._reserved<MID>        slot = ((5 * slot) + perturb + "
    },
    {
        "text": "<PRE>    fn _find_empty_index(self, hash: Int) -> Int:\r\n        var slot = hash % self._reserved\r\n        var perturb = hash\r\n        for _ in range(self._reserved):\r\n            var index = self._get_index(slot)\r\n            if index == Self.EMPTY:\r\n                return slot\r\n<SUF>      abort(\"Dict: no empty index in _find_empty_index\")\r\n        return 0\r<MID>            self._next_index_slot(slot, perturb)\r\n  "
    },
    {
        "text": "<PRE>    fn _over_load_factor(self) -> Bo<SUF>> 2 * self._reserved\r<MID>ol:\r\n        return 3 * self.size "
    },
    {
        "text": "<PRE>    fn _over_compact_factor(self) -> Bool:\r\n        retu<SUF>3 * self._reserved<MID>rn 4 * self._n_entries > "
    },
    {
        "text": "<PRE>    fn _maybe_resize(inout self):\n        if not self._over_load_factor():\n            if self._over_compact_factor():\n                self._compact()\n            return\n        self._reserved *= 2\n        self.size = 0\n        self._n_entries = 0\n        self._index = _DictIndex(self._reserved)\n        var old_entries = self._entries ^\n        self._entries = self._new_entries(s<SUF>):\n            var entry = old_entries.__get_ref(i)[]\n            if entry:\n                self._insert(entry.value())<MID>elf._reserved)\n\n        for i in range(len(old_entries)"
    },
    {
        "text": "<PRE>    fn _compact(inout self):\n        self._index = _DictIndex(self._reserved)\n        var right = 0\n        for left in range(self.size):\n            while not self._entries.__get_ref(right)[]:\n                right += 1\n                debug_assert(right < self._reserved, \"Invalid dict state\")\n            var entry = self._entries.__get_ref(right)[]\n            debug_assert(entry.__bool__(), \"Logic error\")\n            var slot = self._find_empty_index(entry.valu<SUF>] = entry\n                self._entries[right] = None\n\n        self._n_entries = self.size<MID>e().hash)\n            self._set_index(slot, left)\n            if left != right:\n                self._entries[left"
    },
    {
        "text": "<PRE>v<SUF>Pointer[T]<MID>ar data: Any"
    },
    {
        "text": "<PRE>var <SUF>: Int<MID>size"
    },
    {
        "text": "<PRE>var c<SUF>city: Int<MID>apa"
    },
    {
        "text": "<PRE>    fn __i<SUF>AnyPointer[T]()\r\n        self.size = 0\r\n        self.capacity = 0<MID>nit__(inout self):\r\n       \r\n        self.data = "
    },
    {
        "text": "<PRE>    fn __init__(inout self, existing: Self):\r\n\r\n        self._<SUF>y=existing.capacity)\r\n        for e in existing:\r\n            self.append(e[])<MID>_init__(capacit"
    },
    {
        "text": "<PRE>    fn __init__(in<SUF>ut self, *, capacity: Int):\n\n        self.data = AnyPointer[T].alloc(capacity)\n        self.size = 0\n        self.capacity = capacity<MID>o"
    },
    {
        "text": "<PRE>    fn __init__(inout self, *values: T)<SUF>(capacity=len(values))\r\n        for value in values:\r\n            self.append(value[])<MID>:\r\n\r\n        self = Self"
    },
    {
        "text": "<PRE>    fn __moveinit<SUF>self.size = existing.size\n        self.capacity = existing.capacity<MID>__(inout self, owned existing: Self):\n \n        self.data = existing.data\n        "
    },
    {
        "text": "<PRE>    fn __copyinit__(inout self, existing: Self):\r\n\r\n        self<SUF>existing)):\r\n            self.append(existing[i])<MID> = Self(capacity=existing.capacity)\r\n        for i in range(len("
    },
    {
        "text": "<PRE>    fn __del__(owned self):\r\n\r\n        for i in range(self.size<SUF>      _ = (self.data + i).take_value()\r\n        if self.data:\r\n            self.data.free()<MID>):\r\n      "
    },
    {
        "text": "<PRE>    fn __len__<SUF>.size<MID>(self) -> Int:\r\n\r\n        return self"
    },
    {
        "text": "<PRE>    fn _realloc(inout self, new_capacity: Int):\r\n        var ne<SUF>ity)\r\n\r\n        for i in range(self.size):\r\n            (new_data + i).emplace_value((self.data + i).take_value())\r\n\r\n        if self.data:\r\n            self.data.free()\r\n        self.data = new_data\r\n        self.capacity = new_capacity<MID>w_data = AnyPointer[T].alloc(new_capac"
    },
    {
        "text": "<PRE>    fn append(inout self, owned v<SUF>   if self.size >= self.capacity:\r\n            self._realloc(_max(1, self.capacity * 2))\r\n        (self.data + self.size).emplace_value(value ^)\r\n        self.size += 1<MID>alue: T):\r\n\r\n     "
    },
    {
        "text": "<PRE>    fn pop_back(inout self) -> T:\r\n\r\n        var ret_val = (self.data + (self.size - 1)).take_value()\r\n        self.size -= 1\r\n        if self.si<SUF>)\r\n        return ret_val ^<MID>ze * 4 < self.capacity:\r\n            if self.capacity > 1:\r\n                self._realloc(self.capacity // 2"
    },
    {
        "text": "<PRE>    fn reserve(inout self, new_capacity: Int):\r\n\r\n        if self.capacity >= new_capacity:\r\n            return\r\n      <SUF>alloc(new_capacity)<MID>  self._re"
    },
    {
        "text": "<PRE>    fn reverse(inout <SUF>  self._reverse()<MID>self):\r\n        "
    },
    {
        "text": "<PRE>    fn clear(inout self):        for i in range(self.size):\n            <SUF>f.data + i).take_value()\n        self.size = 0<MID>_ = (sel"
    },
    {
        "text": "<PRE>    fn steal_data(i<SUF> 0\r\n        self.capacity = 0\r\n        return ptr<MID>nout self) -> AnyPointer[T]:\r\n\r\n        var ptr = self.data\r\n        self.data = AnyPointer[T]()\r\n        self.size ="
    },
    {
        "text": "<PRE>    fn __setitem__(inout self, i: Int, owned value: T):\r\n       \r\n        debug_assert(-self.size <= i < self.size, \"index must be within bounds\")\r\n\r\n        var normalized_idx = i\r\n  <SUF>take_value()\r\n        (self.data + normalized_idx).emplace_value(value ^)<MID>      if i < 0:\r\n            normalized_idx += len(self)\r\n\r\n        _ = (self.data + normalized_idx)."
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn _adjust_span(self, span: Slice) -> Slice:\r\n      \r\n        var adjusted_span = span\r\n\r\n        if adjusted_span.start < 0:\r\n            adjusted_span.start = len(s<SUF>_span.start - 1\r\n            adjusted_span.start = tmp - 1\r\n\r\n        return adjusted_span<MID>elf) + adjusted_span.start\r\n\r\n        if not adjusted_span._has_end():\r\n            adjusted_span.end = len(self)\r\n        elif adjusted_span.end < 0:\r\n            adjusted_span.end = len(self) + adjusted_span.end\r\n\r\n        if span.step < 0:\r\n            var tmp = adjusted_span.end\r\n            adjusted_span.end = adjusted"
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn __getitem__(self, span: Slice) -> Self:\r\n        \r\n\r\n        var adjusted_span = self._adjust_span(span)\r\n        var adjusted_span_len = len(adjusted_span)\r\n\r\n        if not adjusted_span_len:\r\n            return Self()\r\n\r<SUF>span))\r\n        for i in range(len(adjusted_span)):\r\n            res.append(self[adjusted_span[i]])\r\n\r\n        return res ^<MID>\n        var res = Self(capacity=len(adjusted_"
    },
    {
        "text": "<PRE>    fn __iter__[\r\n        mutability: __mlir_type.`i1`, self_life: AnyLifetime[mutability].type\r\n    ](\r\n        self: Ref<SUF>Self, mutability, self_life].mlir_ref_type,\r\n    ) -> _ListIter[\r\n        T, mutability, self_life\r\n    ]:\r\n       \r\n        return _ListIter[T, mutability, self_life](0, Reference(self))<MID>erence["
    },
    {
        "text": "<PRE>struct Set[T: KeyElement](Sized, Eq<SUF>ityComparable, Hashable, Boolable):\r\n    <MID>ual"
    },
    {
        "text": "<PRE>fn __init__(inout self, *ts: T):\r\n\r\n <SUF>, NoneType]()\r\n        for t in ts:\r\n            self.add(t[])<MID>       self._data = Dict[T"
    },
    {
        "text": "<PRE>    fn __init__(inout self, elements: Self):\r\n \r\n        self.__init__()\r\n   <SUF> self.add(e[])<MID>     for e in elements:\r\n           "
    },
    {
        "text": "<PRE>    fn __init__(in<SUF>     self.__init__()\r\n        for e in elements:\r\n            self.add(e[])\r\n<MID>out self, elements: List[T]):\r\n\r\n   "
    },
    {
        "text": "<PRE>    fn __moveinit__(inout self, owned other: Self):\r\n\r\n   <SUF>^<MID>     self._data = other._data "
    },
    {
        "text": "<PRE>    fn _<SUF> in self._data<MID>_contains__(self, t: T) -> Bool:\r\n \r\n        return t"
    },
    {
        "text": "<PRE>    fn __bool__(self) -> Bool:\r\n\r\n     <SUF>return len(self).__bool__()<MID>   "
    },
    {
        "text": "<PRE>    fn __hash__(self) -> Int:\n\n        var hash_value = 0\n        # Hash combination needs to be commutative so iteration order\n      <SUF>     return hash_value<MID>  # doesn't impact the hash value.\n        for e in self:\n            hash_value ^= hash(e[])\n   "
    },
    {
        "text": "<PRE>    fn __and__(self, other: Self) -> Self:\n\n        re<SUF>other)<MID>turn self.intersection("
    },
    {
        "text": "<PRE>    fn __or__<SUF>      return self.union(other)<MID>(self, other: Self) -> Self:\r\n       \r\n  "
    },
    {
        "text": "<PRE>    fn __ior__(inout<SUF>for e in other:\r\n            self.add(e[])<MID> self, other: Self):\r\n\r\n        "
    },
    {
        "text": "<PRE>    fn __sub__(self, other: Self) -> Self:\r\n\r\n        var r<SUF>          result.add(e[])\r\n        return result ^\r\n<MID>esult = Set[T]()\r\n        for e in self:\r\n            if e[] not in other:\r\n      "
    },
    {
        "text": "<PRE>    fn __isub__(inout self, other: <SUF> self.remove_all(other)<MID>Self):\n\n       "
    },
    {
        "text": "<PRE>    fn add(inout self, t: T):\n\n        sel<SUF>._data[t] = None<MID>f"
    },
    {
        "text": "<PRE>    fn remove(i<SUF>t)<MID>nout self, t: T) raises:\n        self._data.pop("
    },
    {
        "text": "<PRE>    fn pop(inout self) raises -> T:\n\n        if not self:\n            raise \"Pop on empty set\"\n        var iter = self.__iter__()\n        var first = iter.__next<SUF>_()[]\n        self.remove(first)\n        return first<MID>_"
    },
    {
        "text": "<PRE>    fn union(self<SUF>sult.add(o[])\n\n        return result ^<MID>, other: Self) -> Self:\n\n        var result = Set(self)\n        for o in other:\n            re"
    },
    {
        "text": "<PRE>    fn intersection(self, other: Self) -> Self:\n\n        var <SUF> result.add(v[])\n\n        return result ^<MID>result = Set[T]()\n        for v in self:\n            if v[] in other:\n               "
    },
    {
        "text": "<PRE>    fn remove_all(inout self, other: Self):\n\n        for o in other:\n<SUF>except:\n                pass<MID>            try:\n                self.remove(o[])\n            "
    },
    {
        "text": "<PRE>    var conv_layer_one = Conv2D[\r\n        in_channels=1,\r\n        kernel_width=3,\r\n        kernel_height=3,\r\n        stride=1,\r\n        padding=0,\r\n        weight_initialize<SUF>  ]()<MID>r = HeUniform[1],\r\n        activation=\"relu\",\r\n  "
    },
    {
        "text": "<PRE>    var dense2 = Dense[\r\n        in_neuron<SUF>\r\n        activation=\"sigmoid\",\r\n    ]()<MID>s=100,\r\n        out_neurons=10,"
    },
    {
        "text": "<PRE>var true_vals = Tensor[TensorShape(batches<SUF>Zeros]()<MID>, 10), "
    },
    {
        "text": "<PRE> <SUF>ight), Zeros]()<MID>var input = Tensor[TensorShape(batches, channels, width, he"
    },
    {
        "text": "<PRE>var<SUF>w()<MID> epoch_start = no"
    },
    {
        "text": "<PRE>    for epoch in range(1, num_epochs + 1):\n        for i in range(batches):\n            var image = dataset.train_images[i + epoch * batches]\n            var label = dataset.train<SUF>true_vals[i * 10 + label] = 1.0\n            for j in range(width):\n                for k in range(height):\n                    input[i * channels * width * height + j * width + k] = image[\n                        j * width + k\n                    ].to_int()<MID>_labels[i + epoch * batches].to_int()\n            "
    },
    {
        "text": "<PRE>    @always_inline\n  <SUF>_(inout self, value: Scalar[type]):\n\n        self.value = value<MID>  fn __init_"
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn _<SUF>ar[type](value))<MID>_init__(inout self, value: Int):\r\n \r\n        self.__init__(Scal"
    },
    {
        "text": "<PRE>    @staticmethod\n    @always_inl<SUF>`, type.value, `>`],\n        ](\n            bitcast[__mlir_type[`!pop.scalar<`, type.value, `>`]](ptr).address,\n            rhs.value,\n        )<MID>ine\n    fn _fetch_add(\n        ptr: Pointer[Scalar[type]], rhs: Scalar[type]\n    ) -> Scalar[type]:\n\n        return __mlir_op.`pop.atomic.rmw`[\n            bin_op = __mlir_attr.`#pop<bin_op add>`,\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\n            _type = __mlir_type[`!pop.scalar<"
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn fetch_add(inout self, rhs: Scalar[type]) -> Scalar[type]:\r\n\r\n        <SUF>\n        return Self._fetch_add(value_addr, rhs)<MID>var value_addr = Pointer.address_of(self.value)\r"
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn __iadd__(inout self, rhs: Scalar[type])<SUF>  _ = self.fetch_add(rhs)<MID>:\r\n\r\n      "
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn fetch_sub(inout self, rhs: Scalar[type]) -> Scalar[type]:\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        return __mlir<SUF>calar<`, type.value, `>`],\r\n        ](value_addr.address, rhs.value)<MID>_op.`pop.atomic.rmw`[\r\n            bin_op = __mlir_attr.`#pop<bin_op sub>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type[`!pop.s"
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn __isub_<SUF>hs: Scalar[type]):\r\n\r\n        _ = self.fetch_sub(rhs)<MID>_(inout self, r"
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn max(inout self, rhs: Scalar[type]):\r\n\r\n        constrained[\r\n            type.is_integral() or type.is_floating_point(),\r\n            \"the input type must be arithmetic\",\r\n        ]()\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        _ = __mlir_op.`pop.atomic.rmw`[\r\n<SUF>     ](value_addr.address, rhs.value)<MID>            bin_op = __mlir_attr.`#pop<bin_op max>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type[`!pop.scalar<`, type.value, `>`],\r\n   "
    },
    {
        "text": "<PRE>    @always_inline\r\n    fn min(inout self, rhs: Scalar[type]):\r\n\r\n\r\n        constrained[\r\n            type.is_integral() or type.is_floating_point(),\r\n            \"the input type must be arithmetic\",<SUF>`!pop.scalar<`, type.value, `>`],\r\n        ](value_addr.address, rhs.value)<MID>\r\n        ]()\r\n\r\n        var value_addr = Pointer.address_of(self.value.value)\r\n        _ = __mlir_op.`pop.atomic.rmw`[\r\n            bin_op = __mlir_attr.`#pop<bin_op min>`,\r\n            ordering = __mlir_attr.`#pop<atomic_ordering seq_cst>`,\r\n            _type = __mlir_type["
    },
    {
        "text": "<PRE>fn setenv(name: String, value<SUF>f overwrite else 0)\r\n    )\r\n    return status == 0<MID>: String, overwrite: Bool = True) -> Bool:\r\n\r\n    alias os_is_supported = os_is_linux() or os_is_macos()\r\n    if not os_is_supported:\r\n        return False\r\n\r\n    var status = external_call[\"setenv\", Int32](\r\n        name._as_ptr(), value._as_ptr(), Int32(1 i"
    },
    {
        "text": "<PRE>fn getenv(name: St<SUF>s_is_supported:\r\n        return default\r\n\r\n    var ptr = external_call[\"getenv\", DTypePointer[DType.int8]](name._as_ptr())\r\n    if not ptr:\r\n        return default\r\n    return String(StringRef(ptr))<MID>ring, default: String = \"\") -> String:\r\n\r\n    alias os_is_supported = os_is_linux() or os_is_macos()\r\n\r\n    if not o"
    },
    {
        "text": "<PRE>fn stat[p<SUF>) raises -> stat_result:\r\n\r\n    return stat(path.__fspath__())\r\n<MID>athlike: os.PathLike](path: pathlike"
    },
    {
        "text": "<PRE>fn list(self)<SUF>\r\n            return self._list_linux()\r\n        else:\r\n            return self._list_macos()<MID> -> List[String]:\r\n\r\n\r\n        @parameter\r\n        if os_is_linux():"
    },
    {
        "text": "<PRE>    fn __del__(owned self):\r\n      \r\n       <SUF>nal_call[\"closedir\", Int32](self._handle)<MID> _ = exter"
    },
    {
        "text": "<PRE>fn li<SUF>g = \"\") raises -> List[String]:\r\n\r\n\r\n    var dir = _DirHandle(path)\r\n    return dir.list()<MID>stdir(path: Strin"
    },
    {
        "text": "<PRE>fn listdir[pathlike: os.PathLike](path: pathlike) raises -> List[String]<SUF>\r\n\r\n    return listdir(path.__fspath__())<MID>:"
    },
    {
        "text": "<PRE>@always_inline(\"nodebug\")\r\nfn abort[result: Movable = NoneType]() -> result:\r\n<SUF>er[result]().take_value()<MID>\r\n\r\n    __mlir_op.`llvm.intr.trap`()\r\n\r\n    return AnyPoint"
    },
    {
        "text": "<PRE>@always_inline(\"nodebug\")\r\nfn abort[\r\n    result: Movable = NoneTyp<SUF>rt[result]()<MID>e, *, stringable: Stringable\r\n](message: stringable) -> result:\r\n \r\n\r\n    @parameter\r\n    if not triple_is_nvidia_cuda():\r\n        print(message, flush=True)\r\n\r\n    return abo"
    },
    {
        "text": "<PRE>    fn __init__(inout self, path: String) raises:\n\n        constrained[\n            not os_is_windows(), \"operation is only available on unix systems\"\n        ]()\n\n        if not isdir(path):\n            raise \"the directory '\" + path + \"' does not exist\"\n\n        self._handle = external_call[\"opendir\", Pointer[NoneType]](\n            path._as_ptr()\n        )\n\n      <SUF>e directory '\" + path + \"'\"<MID>  if not self._handle:\n            raise \"unable to open th"
    },
    {
        "text": "<PRE>@al<SUF>), Pointer.address_of(ts)\r\n    )\r\n\r\n    return ts<MID>ways_inline\r\nfn _clock_gettime(clockid: Int) -> _CTimeSpec:\r\n  \r\n    var ts = _CTimeSpec()\r\n\r\n    # Call libc's clock_gettime.\r\n    _ = external_call[\"clock_gettime\", Int32](\r\n        Int32(clockid"
    },
    {
        "text": "<PRE>@always_inline\r\nfn _realtime_nanoseconds() -> Int:<SUF> return _gettime_as_nsec_unix(_CLOCK_REALTIME)<MID>\r\n   \r\n   "
    },
    {
        "text": "<PRE>@always_inline\r\nfn _monotonic_nanoseconds() -> Int:\r\n    \r\n\r\n    @parameter\r\n    if os_is_windows():\r\n        var ft = _FILETIME()\r\n        external_call[\"GetSystemTimePreciseAsFileTime\", NoneType](\r\n            Poin<SUF>K_MONOTONIC)<MID>ter.address_of(ft)\r\n        )\r\n\r\n        return ft.as_nanoseconds()\r\n    else:\r\n        return _gettime_as_nsec_unix(_CLOC"
    },
    {
        "text": "<PRE>@always_inline\r\nfn _monotonic_raw_nanoseconds() -> Int:\r\n  \r\n\r\n    retur<SUF>TONIC_RAW)<MID>n _gettime_as_nsec_unix(_CLOCK_MONO"
    },
    {
        "text": "<PRE>@always_inline\r\nfn _process_<SUF>ME_ID)<MID>cputime_nanoseconds() -> Int:\r\n   \r\n\r\n    return _gettime_as_nsec_unix(_CLOCK_PROCESS_CPUTI"
    },
    {
        "text": "<PRE>@al<SUF>s_inline\nfn now() -> Int:\n\n    return _monotonic_nanoseconds()<MID>way"
    },
    {
        "text": "<PRE>@always_inline\n@parameter\nfn time_function[func: fn <SUF>func]()\n\n    var tic = now()\n    func()\n    var toc = now()\n    return toc - tic<MID>() capturing -> None]() -> Int:\n\n\n    @parameter\n    if os_is_windows():\n        return _time_function_windows["
    },
    {
        "text": "<PRE>fn sleep(sec: Int):\n\n\n    @parameter\n    if os_is_windows():\n        external_call[\"Sleep\", NoneType<SUF>leep\", NoneType](sec)<MID>](sec * 1000)\n    else:\n        external_call[\"s"
    },
    {
        "text": "<PRE>    @always_inline(\"<SUF>g\")\r\n    fn __lt__(self, rhs: Self) -> Bool:\r\n\r\n        return int(self) < int(rhs)<MID>nodebu"
    },
    {
        "text": "<PRE>fn pow(base: Int, exp: In<SUF>eturn base ** exp<MID>t = 2) -> Int:\r\n    r"
    }
]